{
  "hash": "1e5f1348b173cf4a70faf4a4416581c4",
  "result": {
    "markdown": "---\nlang: es\n---\n\n\n\n\n# Estructuras de control\n\nComo en otros lenguajes de programación, en R existen instrucciones para controlar el flujo de ejecución de un programa. Básicamente existen dos tipos: \n\n- Condicionales: Son instrucciones que bifurcan el flujo del programa en función de si se cumple o no una condición.\n- Bucles: Son instrucciones que repiten un bloque de código un numero determinado de veces o hasta que se cumple una condición. \n\n## Estructuras condicionales\n\nLas estructuras condicionales permiten evaluar el estado del programa y tomar decisiones sobre qué código ejecutar en función del mismo.\n\n### Condicionales (`if`)\n\nLa principal estructura condicional comienza con la palabra reservada `if`, lleva asociada expresión de tipo lógico o booleano y permite ejecutar un bloque de código dependiendo de si la evaluación de esa expresión es `TRUE` o `FALSE`.\n\n> `if (`_`<exp>`_`) {`  \n&ensp;&ensp;_`<código>`_  \n`}`\n\nSi el resultado de evaluar la expresión `<exp>` es `TRUE` entonces se ejecuta el código `<código>`, mientras que si es `FALSE` no.\n\n![Diagrama de flujo de la estructura condicional simple](img/04-estructuras-control/condicional-simple.png)\n\n\n\n\n::: {.cell layout-align=\"center\" hash='04-estructuras-control_cache/epub/condicional-simple_3ec59901981ecc8a16bf16e8a79f5198'}\n::: {.cell-output-display}\n![Diagrama de flujo de la estructura condicional simple](img/04-estructuras-control/condicional-simple.png){fig-align='center' width=70%}\n:::\n:::\n\n\n\n\n:::{#exm-condicional-simple}\n\n\n\n::: {.cell hash='04-estructuras-control_cache/epub/unnamed-chunk-1_224d9d4990052268d7606ea5bed342b5'}\n\n```{.r .cell-code}\nx <- 1\ny <- 0\nif (y != 0){\n  print(x / y)\n}\n```\n:::\n\n\n\n:::\n\nSi se desea ejecutar un bloque de código alternativo cuando no se cumpla la condición se puede añadir a continuación con la palabra reservada `else`.\n\n> `if (`_`<exp>`_`) {`  \n&ensp;&ensp;_`<código 1>`_  \n`} else {`  \n&ensp;&ensp;_`<código 2>`_  \n`}`\n\nEn este caso, si la evaluación de la condición es `TRUE` se ejecuta el código `<código 1>` y si es `FALSE` se ejecuta el código `<código 2>`.\n\n![Diagrama de flujo de la estructura condicional doble](img/04-estructuras-control/condicional-doble.png)\n\n:::{#exm-condicional-doble}\n\n\n\n::: {.cell hash='04-estructuras-control_cache/epub/unnamed-chunk-2_b1a28322e7a7c2cb75b6a792aa6701a1'}\n\n```{.r .cell-code}\nnota <- 8.5\nif (nota < 5){\n  print(\"Suspenso\")\n} else {\n  print(\"Aprobado\")\n}\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"Aprobado\"\n```\n:::\n:::\n\n\n\n:::\n\nSe puede comprobar más de una condición encadenando otra instrucción `if` tras las instrucción `else`. \n\n> `if (`_`<exp 1>`_`) {`  \n&ensp;&ensp;_`<código 1>`_  \n`} else if (`_`<exp 2>`_`) {`  \n&ensp;&ensp;_`<código 2>`_`) {`  \n...  \n`} else {`  \n&ensp;&ensp;_`<código n>`_  \n`}`\n\nCuando se encadenan múltiples condiciones de esta forma, solamente se ejecuta el bloque de código asociado a la primera condición cuya evaluación sea `TRUE`. El último bloque de código solamente se ejecuta si todas las condiciones son falsas.\n\n![Diagrama de flujo de la estructura condicional múltiple](img/04-estructuras-control/condicional-multiple.png)\n\n:::{#exm-condicional-multiple}\n\n\n\n::: {.cell hash='04-estructuras-control_cache/epub/unnamed-chunk-3_ec68c43fbe661e75c60c995a803980b7'}\n\n```{.r .cell-code}\nnota <- 8.5\nif (nota < 5){\n  print(\"Suspenso\")\n} else if (nota < 7) {\n  print(\"Aprobado\")\n} else if (nota < 9) {\n  print(\"Notable\")\n} else {\n  print(\"Sobresaliente\")\n}\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"Notable\"\n```\n:::\n:::\n\n\n\n:::\n\n\n### La función `switch()`\n\nOtra forma de tomar decisiones sobre el código a ejecutar es la función `switch`. \n\n- `switch(x, l)`: Ejecuta el código del valor de la lista `l` cuyo nombre asociado coincide con el resultado de evaluar la expresión `x`. Si el resultado de evaluar `x` no es ningún nombre de los elementos de la lista devuelve `NULL`.\n\n:::{#exm-condicional-switch}\n\n\n\n::: {.cell hash='04-estructuras-control_cache/epub/unnamed-chunk-4_e4f45889d9a8c257edc4d1abb1f97212'}\n\n```{.r .cell-code}\ntipo.iva <- \"reducido\"\nprecio <- 1000\niva <- precio * switch(tipo.iva, \"superreducido\" = 4, \"reducido\" = 10, \"normal\" = 21) / 100\niva\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 100\n```\n:::\n:::\n\n\n\n:::\n\n## Bucles\n\nUn bucle es una estructura que permite la repetición de un bloque de código. En R existen dos tipos de bucles, los _bucles iterativos_ y los _bucles condicionales_.\n\n### Bucles iterativos (`for`)\n\nLo bucles iterativos repiten un bloque de código un número determinado de veces. Comienzan por la palabra reservada `for` y llevan asociado un _iterador_, que es una variable que recorre una secuencia de un tipo de datos compuesto, normalmente un vector o una lista. El bloque de código se ejecuta tantas veces como elementos tenga la secuencia, y en cada repetición el iterador toma como valor un elemento distinto de la secuencia.\n\n> `for (`_`i`_ ` in ` _`<secuencia>`_`) {`  \n&ensp;&ensp;_`<código>`_  \n`}`\n\n![Diagrama de flujo de un bucle iterativo](img/04-estructuras-control/bucle-for.png)\n\n:::{#exm-bucle-iterarivo}\nA continuación se muestra varios ejemplos de uso del bucle `for`.\n\n\n\n::: {.cell hash='04-estructuras-control_cache/epub/unnamed-chunk-5_e4e73f4678c8c18ad1dde60ca56f8fbe'}\n\n```{.r .cell-code}\nasignaturas <- c(\"Matemáticas\", \"Física\", \"Programación\")\nfor (i in asignaturas) {\n  print(i)\n}\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"Matemáticas\"\n[1] \"Física\"\n[1] \"Programación\"\n```\n:::\n\n```{.r .cell-code}\nfor (i in 1:5) {\n  print(paste(\"El cuadrado de \", i, \" es \", i^2))\n}\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"El cuadrado de  1  es  1\"\n[1] \"El cuadrado de  2  es  4\"\n[1] \"El cuadrado de  3  es  9\"\n[1] \"El cuadrado de  4  es  16\"\n[1] \"El cuadrado de  5  es  25\"\n```\n:::\n:::\n\n\n\n:::\n\nTambién es posible recorrer los elementos de la secuencia por posición ayudándonos de la siguiente función:\n\n- `seq_along(x)`: que devuelve un vector con los enteros desde 1 hasta el número de elementos de la secuencia `x`.\n\n:::{#exm-bucle-iterativo-posicion}\n\n\n\n::: {.cell hash='04-estructuras-control_cache/epub/unnamed-chunk-6_b652476805e8a0a8a9bc8c132b9ecd18'}\n\n```{.r .cell-code}\nasignaturas <- c(\"Matemáticas\", \"Física\", \"Programación\")\nfor (i in seq_along(asignaturas)){\n  print(paste(\"Asignatura \", i, \":\", asignaturas[i]))\n}\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"Asignatura  1 : Matemáticas\"\n[1] \"Asignatura  2 : Física\"\n[1] \"Asignatura  3 : Programación\"\n```\n:::\n:::\n\n\n\n:::\n\nLos bucles iterativos se utilizan habitualmente para recorrer estructuras de una dimensión como los vectores y las listas, donde se sabe de antemano el número de elementos que contiene y, por tanto, el número de iteraciones del bucle. No obstante, también se pueden recorrer estructuras de más de una dimensión, como por ejemplo matrices, utilizando varios bucles `for` anidados.\n\n:::{#exm-bucles-anidados}\nA continuación se muestra varios ejemplos de dos bucles `for` anidados para recorrer los elementos de una matriz.\n\n\n\n::: {.cell hash='04-estructuras-control_cache/epub/unnamed-chunk-7_4e1d26d2524aa3259e78b0e468bbfc16'}\n\n```{.r .cell-code}\nx <- matrix(1:6, 2, 3)\nfor (i in 1:nrow(x)) {\n  for (j in 1:ncol(x)){\n    print(x[i,j])\n  }\n}\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1\n[1] 3\n[1] 5\n[1] 2\n[1] 4\n[1] 6\n```\n:::\n:::\n\n\n\n:::\n\n### Bucles condicionales (`while`)\n\nLos bucles condicionales repiten un bloque de código mientras se cumpla una condición. Comienzan con la palabra reservada `while` y llevan asociada una expresión lógica, de manera que mientras la evaluación de la expresión lógica sea `TRUE` se repite la ejecución del bloque de código que contiene.\n\n> `while (`_`<condición>`_`) {`  \n&ensp;&ensp;_`<código>`_  \n`}`\n\nLa expresión lógica `<condición>` se evalúa antes de ejecutar el bloque de código y solo se ejecuta el `<código>` si el resultado de la evaluación es `TRUE`. Obsérvese que cuando el flujo de ejecución del programa llega al bucle `while` si la condición no es cierta, el código no se ejecuta ni tan siquiera una vez.\n\n![Diagrama de flujo de un bucle condicional](img/04-estructuras-control/bucle-while.png)\n\n:::{#exm-bucle-condicional}\n\n\n\n::: {.cell hash='04-estructuras-control_cache/epub/unnamed-chunk-8_a2a95398c6bfbd39cd9b74299d130b9b'}\n\n```{.r .cell-code}\ni <- 5\nwhile (i >= 0) {\n  print(i)\n  i <- i - 1\n}\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 5\n[1] 4\n[1] 3\n[1] 2\n[1] 1\n[1] 0\n```\n:::\n:::\n\n\n\n:::\n\n### La instrucción `break`\n\nLa instrucción `break` se utiliza para detener un bucle y salir de él, tanto en bucles iterativos como en bucles condicionales. Normalmente se suele utilizar esta instrucción cuando se cumple una determinada condición en bloque de código del bucle y se decide parar su ejecución y salir del bucle.\n\n:::{#exm-salida-bucle-break}\n\n\n\n::: {.cell hash='04-estructuras-control_cache/epub/unnamed-chunk-9_72cc4575fa2718242eafd50c5509d5e2'}\n\n```{.r .cell-code}\n# Bucle que recorre los números enteros del -2 al 2 pero termina al llegar al 0.\nfor (i in -2:2) {\n  if (i == 0) {\n    break\n  } \n  print(i)\n}\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] -2\n[1] -1\n```\n:::\n:::\n\n\n\n:::\n\n### La instrucción `next`\n\nLa instrucción `next` se utiliza para interrumpir la ejecución del bloque de código de un bucle, pero en lugar de salir del bucle pasa a la siguiente iteración. Si se trata de un bucle iterativo el iterador pasa al siguiente elemento de la secuencia de iteración y si se trata de un bucle condicional se pasa evaluar de nuevo la condición de repetición. \n\n:::{#exm-continuacion-bucle-next}\n\n\n\n::: {.cell hash='04-estructuras-control_cache/epub/unnamed-chunk-10_45c0e0d5c5c2686f21c89d9da4dbd385'}\n\n```{.r .cell-code}\n# Bucle que recorre los enteros del 1 al 10 pero solo imprime los números pares.\nfor (i in 1:10) {\n  if (i %% 2) {\n    next\n  }\n  print(i)\n}\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 2\n[1] 4\n[1] 6\n[1] 8\n[1] 10\n```\n:::\n:::\n\n\n\n\n## Ejercicios\n\n:::{#exr-estructuras-control-1}\nConsidérese el data frame creado en el @exr-datos-estructurados-1.\n\n\n\n\n::: {.cell hide='true' hash='04-estructuras-control_cache/epub/unnamed-chunk-11_b2f5f5323066ec92c39951693c6fb3db'}\n\n```{.r .cell-code}\nnombre <- c(\"Carlos\", \"María\", \"Carmen\", \"Pedro\", \"Luis\", \"Sara\")\nsexo <- c(\"H\", \"M\", \"M\", \"H\", \"H\", \"M\")\nfisica <- c(6.7, 7.2, 5.5, NA, 3.5, 6.2)\nquimica <- c(8.1, 9.5, 5, 4.5, 5, 4)\ndf <- data.frame(nombre, sexo, fisica, quimica)\n```\n:::\n\n\n\n\na. Usando la función `mean()`, calcular la media de Física y de Química usando un bucle iterativo.\n\n:::{.callout-note collapse=\"true\"}\n## Solución \n\n\n\n::: {.cell hash='04-estructuras-control_cache/epub/unnamed-chunk-12_2476bd5a4db57ac97ae2b68105181f1b'}\n\n```{.r .cell-code}\nmedias <- NULL\nfor (i in 3:4){\n  medias <- c(medias, mean(df[[i]], na.rm=TRUE))\n}\nmedias\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 5.820000 6.016667\n```\n:::\n:::\n\n\n\n:::\n\n\n crear una nueva columna con la calificación (suspenso, aprobado, notable, sobresaliente) de las notas de Física y Química.\n\n:::{.callout-note collapse=\"true\"}\n## Solución \n\n\n\n::: {.cell hide='true' hash='04-estructuras-control_cache/epub/unnamed-chunk-13_f6b304fcb1e715e6422b77f1b8e20fba'}\n\n```{.r .cell-code}\nnombre <- c(\"Carlos\", \"María\", \"Carmen\", \"Pedro\", \"Luis\", \"Sara\")\nsexo <- c(\"H\", \"M\", \"M\", \"H\", \"H\", \"M\")\nfisica <- c(6.7, 7.2, 5.5, NA, 3.5, 6.2)\nquimica <- c(8.1, 9.5, 5, 4.5, 5, 4)\ndf <- data.frame(nombre, sexo, fisica, quimica)\n```\n:::\n\n::: {.cell hash='04-estructuras-control_cache/epub/unnamed-chunk-14_71f7b19df3652140c7cdff0d64307e6f'}\n\n```{.r .cell-code}\nfor (i in 1:nrow(df)){\n  \n}\n```\n:::\n\n\n\n\n:::\n:::",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {
      "knitr": [
        "{\"type\":\"list\",\"attributes\":{},\"value\":[]}"
      ]
    },
    "preserve": null,
    "postProcess": false
  }
}