{
  "hash": "d74179d32b9ca53cd5fe8a2a1f4ac5d4",
  "result": {
    "markdown": "---\nlang: es\n---\n\n\n\n# Tipos de datos simples\n\nEn R existen distintos tipos de datos simples predefinidos:\n\n- `numeric`: Es el tipo de los números. Secuencia de dígitos (pueden incluir el - para negativos y el punto como separador de decimales) que representan números.  Por ejemplo, `1`, `-2.0`, `3.1415` o `4.5e3`.  \nPor defecto, cualquier número que se teclee tomará este tipo.\n\n  - `integer`: Es el tipo de los números enteros. Secuencia de dígitos sin separador de decimales que representan un número entero. Por ejemplo `1` o `-2`. Son una subclase del tipo de datos numérico. \n  \n  - `double`: Es el tipo de los números reales. Secuencia de dígitos que incluyen decimales separados por punto. Por ejemplo `3.1415` o `-2.0`. Son una subclase del tipo de datos numérico.\n\n- `character`: Es el tipo de las cadenas de caracteres. Secuencia de caracteres alfanuméricos que representan texto. Se escriben entre comillas simples o dobles. Por ejemplo `\"Hola\"` o `'Hola'`.  \n\n- `logical`: Es el tipo de los booleanos. Puede tomar cualquiera de los dos valores lógicos `TRUE` (verdadero) o `FALSE` (falso). También se pueden abreviar como `T` o `F`.  \n\n- `NA`: Se utiliza para representar datos desconocidos o perdidos. Aunque en realidad es un dato lógico, puede considerarse con un tipo de dato especial.\n\n- `NULL`: Se utiliza para representar la ausencia de datos. La principal diferencia con `NA` es que `NULL` aparece cuando se intenta acceder a un dato que no existe, mientras que `NA` se utiliza para representar explícitamente datos perdidos en un estudio. \n\n\nPara averiguar el tipo de un dato se puede utilizar la siguiente función:\n\n- `class(x)`: Devuelve el tipo del dato `x`.\n\n:::{#exm-tipos-datos}\nA continuación se muestran los tipos de algunos datos.\n\n\n::: {.cell hash='02-tipos-datos-simples_cache/pdf/unnamed-chunk-1_b97cf23661be6f5f066d1f98b0edaae1'}\n\n```{.r .cell-code}\nclass(3.1415)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"numeric\"\n```\n:::\n\n```{.r .cell-code}\nclass(-1)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"numeric\"\n```\n:::\n\n```{.r .cell-code}\nclass(\"Hola\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"character\"\n```\n:::\n\n```{.r .cell-code}\nclass(TRUE)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"logical\"\n```\n:::\n\n```{.r .cell-code}\nclass(NA)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"logical\"\n```\n:::\n\n```{.r .cell-code}\nclass(NULL)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"NULL\"\n```\n:::\n:::\n\n\n:::\n\nTambién pueden utilizarse las siguientes funciones que devuelven un booleano:\n\n- `is.numeric(x)`: Devuelve el booleano `TRUE` si `x` es del tipo `numeric`. \n- `is.double(x)`: Devuelve el booleano `TRUE` si `x` es del tipo `double`.\n- `is.integer(x)`: Devuelve el booleano `TRUE` si `x` es del tipo `integer`. \n- `is.character(x)`: Devuelve el booleano `TRUE` si `x` es del tipo `character`. \n- `is.logical(x)`: Devuelve el booleano `TRUE` si `x` es del tipo `logical`. \n- `is.na(x)`: Devuelve el booleano `TRUE` si `x` es del tipo `NA`. \n- `is.null(x)`: Devuelve el booleano `TRUE` si `x` es del tipo `NULL`. \n\n:::{#exm-tipos-datos-2}\n\n\n::: {.cell hash='02-tipos-datos-simples_cache/pdf/unnamed-chunk-2_44bdaedc781ef1dc1a289827d10c0a12'}\n\n```{.r .cell-code}\nis.double(3.1415)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n\n```{.r .cell-code}\nis.character(TRUE)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] FALSE\n```\n:::\n:::\n\n\n:::\n\n## Conversión de tipos\n\nEn muchas ocasiones es posible convertir un dato de un tipo a otro distinto. Para ello se usan las siguientes funciones:\n\n- `as.numeric(x)`: Convierte el dato de `x` al tipo `numeric` siempre que sea posible o tenga sentido la conversión. Para convertir una cadena en un número, la cadena tiene que representar un número. El valor lógico `TRUE` se convierte en 1 y el `FALSE` en 0.\n- `as.integer(x)`: Convierte el dato de `x` al tipo `integer` siempre que sea posible o tenga sentido la conversión. Para convertir una cadena en un número entero, la cadena tiene que representar un número entero. El valor lógico `TRUE` se convierte en 1 y el `FALSE` en 0.\n- `as.character(x)`: Convierte el tipo de dato de `x` al tipo `character` simplemente añadiendo comillas.\n- `as.logical(x)`: Convierte el tipo de dato de `x` al tipo lógico. Para datos numéricos, el 0 se convierte en `FALSE` y cualquier otro número en `TRUE`. Para cadenas se obtiene `NA` excepto para las cadenas `\"TRUE\"` y `\"true\"` que se convierten a `TRUE` y las cadenas `\"FALSE\"` y `\"false\"` que se convierten a `FALSE`.\n\nEl tipo `NA` no se puede convertir a ningún otro tipo pues representa la ausencia del dato. Lo mismo ocurre con `NULL`.\n\n## Operaciones con números\n\n### Operadores aritméticos\n\nLos siguientes operadores permiten realizar las clásicas operaciones aritméticas entre datos numéricos:\n\n- `x + y`: Devuelve la suma de `x` e `y`.\n- `x - y`: Devuelve la resta de `x` e `y`. \n- `x * y`: Devuelve el producto de `x` e `y`.\n- `x / y`: Devuelve el cociente de `x` e `y`.  \n- `x %% y`: Devuelve el resto de la división entera de `x` e `y`.  \n- `x ^ y`: Devuelve la potencia `x` elevado a `y`.\n\n:::{#exm-operadores-aritmeticos}\nA continuación se muestran varios ejemplos de operaciones aritméticas.\n\n\n::: {.cell hash='02-tipos-datos-simples_cache/pdf/unnamed-chunk-3_71c5e0ace82f08874424fda16b1bcbe5'}\n\n```{.r .cell-code}\n2 + 3\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 5\n```\n:::\n\n```{.r .cell-code}\n5 * -2\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] -10\n```\n:::\n\n```{.r .cell-code}\n5 / 2\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 2.5\n```\n:::\n\n```{.r .cell-code}\n1 / 0\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] Inf\n```\n:::\n\n```{.r .cell-code}\n5 %% 2\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1\n```\n:::\n\n```{.r .cell-code}\n2 ^ 3\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 8\n```\n:::\n:::\n\n\n:::\n\n### Operadores relacionales \n\nComparan dos números y devuelven un valor lógico.\n\n- `x == y`: Devuelve `TRUE` si el número `x` es igual que el número `y`, y `FALSE` en caso contrario.\n- `x > y`: Devuelve `TRUE` si el número `x` es mayor que el número `y`, y `FALSE` en caso contrario.\n- `x < y`: Devuelve `TRUE` si el número `x` es menor que el número `y`, y `FALSE` en caso contrario.\n- `x >= y`: Devuelve `TRUE` si el número `x` es mayor o igual que el número `y`, y `FALSE` en caso contrario.\n- `x <= y`: Devuelve `TRUE` si el número `x` es menor o igual a que el número `y,` y `FALSE` en caso contrario.\n- `x != y`: Devuelve `TRUE` si el número `x` es distinto del número `y`, y `FALSE` en caso contrario.\n\n:::{#exm-operadores-relacionales}\nA continuación se muestran varios ejemplos de operaciones relacionales.\n\n\n::: {.cell hash='02-tipos-datos-simples_cache/pdf/unnamed-chunk-4_19a46d445188a051516331f6be6bda07'}\n\n```{.r .cell-code}\n3 == 3\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n\n```{.r .cell-code}\n3.1 <= 3\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] FALSE\n```\n:::\n\n```{.r .cell-code}\n4 > 3\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n\n```{.r .cell-code}\n-1 != 1\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n\n```{.r .cell-code}\n5 %% 2\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1\n```\n:::\n\n```{.r .cell-code}\n2 ^ 3\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 8\n```\n:::\n\n```{.r .cell-code}\n(2 + 3) ^ 2\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 25\n```\n:::\n:::\n\n\n:::\n\n### Funciones y constantes numéricas\n\nLas siguientes constantes y funciones matemáticas también están ya predefinidas.\n\n- `pi`: Devuelve el número $\\pi$.\n- `sqrt(x)`: Devuelve la raíz cuadrada de `x`.\n- `abs(x)`: Devuelve el valor absoluto de `x`.\n- `round(x, n)`: Devuelve el redondeo de `x` a `n` decimales.\n- `exp(x)`: Devuelve la exponencial de `x` ($e^x$).\n- `log(x)`: Devuelve el logaritmo neperiano de `x`.\n- `sin(x)`: Devuelve el seno del ángulo `x` en radianes.\n- `cos(x)`: Devuelve el coseno del ángulo `x` en radianes.\n- `tan(x)`: Devuelve la tangente del ángulo `x` en radianes.\n- `asin(x)`: Devuelve el arcoseno de `x`.\n- `acos(x)`: Devuelve el arcocoseno de `x`.\n- `atan(x)`: Devuelve el arcotangente de `x`.\n\n---\n\n:::{#exm-funciones-numéricas}\n\n\n::: {.cell hash='02-tipos-datos-simples_cache/pdf/unnamed-chunk-5_83b0da712437995afe2ff5c6e61172d7'}\n\n```{.r .cell-code}\nsqrt(9)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 3\n```\n:::\n\n```{.r .cell-code}\nabs(-1)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1\n```\n:::\n\n```{.r .cell-code}\nround(1.7)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 2\n```\n:::\n\n```{.r .cell-code}\nexp(1)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 2.718282\n```\n:::\n\n```{.r .cell-code}\nlog(exp(1))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1\n```\n:::\n\n```{.r .cell-code}\ncos(pi)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] -1\n```\n:::\n\n```{.r .cell-code}\nasin(1)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1.570796\n```\n:::\n:::\n\n\n:::\n\n## Operaciones con cadenas\n\n### Funciones de cadenas\n\nExisten muchas funciones para cadenas de texto pero las más comunes son: \n\n- `nchar(c)`: Devuelve el número de caracteres de la cadena.\n- `paste(x, y, ..., sep=s)`: Concatena las cadenas `x`, `y`, etc. separándolas por la cadena `s`. Por defecto la cadena de separación es un espacio en blanco.\n- `substr(c, start=i, stop=j)`: Devuelve la subcadena de la cadena `c` desde la posición `i` hasta la posición `j`. El primer carácter de una cadena ocupa la posición 1.\n- `tolower(c)`: Devuelve la cadena que resulta de convertir la cadena `c` a minúsculas.\n- `toupper(c)`: Devuelve la cadena que resulta de convertir la cadena `c` a mayúsculas.\n\n:::{#exm-operaciones-cadenas}\nA continuación se muestran varios ejemplos de operaciones con cadenas de texto.\n\n\n::: {.cell hash='02-tipos-datos-simples_cache/pdf/unnamed-chunk-6_c629f74ea5b584693fa885c3a31b2400'}\n\n```{.r .cell-code}\nnchar(\"Me gusta R\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 10\n```\n:::\n\n```{.r .cell-code}\npaste(\"Me\", \"gusta\", \"R\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"Me gusta R\"\n```\n:::\n\n```{.r .cell-code}\npaste(\"Me\", \"gusta\", \"R\", sep = \"-\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"Me-gusta-R\"\n```\n:::\n\n```{.r .cell-code}\npaste(\"Me\", \"gusta\", \"R\", sep = \"\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"MegustaR\"\n```\n:::\n\n```{.r .cell-code}\nsubstr(\"Me gusta R\", 4, 8)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"gusta\"\n```\n:::\n\n```{.r .cell-code}\ntolower(\"Me gusta R\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"me gusta r\"\n```\n:::\n\n```{.r .cell-code}\ntoupper(\"Me gusta R\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"ME GUSTA R\"\n```\n:::\n:::\n\n\n:::\n\n### Operaciones de comparación de cadenas\n\n- `x == y` : Devuelve `TRUE` si la cadena `x` es igual que la cadena `y`, y `FALSE` en caso contrario.\n- `x > y` : Devuelve `TRUE` si la cadena `x` sucede a la cadena `y`, y `FALSE` en caso contrario.\n- `x < y` : Devuelve `TRUE` si la cadena `x` antecede a la cadena `y`, y `FALSE` en caso contrario.\n- `x >= y` : Devuelve `TRUE` si la cadena `x` sucede o es igual a la cadena `y`, y `FALSE` en caso contrario.\n- `x <= y` : Devuelve `TRUE` si la cadena `x` antecede o es igual a la cadena `y`, y `FALSE` en caso contrario.\n- `x != y` : Devuelve `TRUE` si la cadena `x` es distinta de la cadena `y`, y `FALSE` en caso contrario.\n\n<i class=\"fa fa-exclamation-triangle\" style=\"color:red;\"></i> _Utilizan el orden alfabético, las minúsculas van antes que las mayúsculas, y los números antes que las letras._\n\n:::{#exm-operaciones-comparacion-cadenas}\nA continuación se muestran varios ejemplos de operaciones de comparación de cadenas.\n\n\n::: {.cell hash='02-tipos-datos-simples_cache/pdf/unnamed-chunk-7_cc15e69ac0b1e67cff62d0e22bdd8130'}\n\n```{.r .cell-code}\n\"R\" == \"R\"\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n\n```{.r .cell-code}\n\"R\" == \"r\"\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] FALSE\n```\n:::\n\n```{.r .cell-code}\n\"uno\" < \"dos\"\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] FALSE\n```\n:::\n\n```{.r .cell-code}\n\"A\" > \"a\"\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n\n```{.r .cell-code}\n\"\" < \"R\"\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n:::\n\n\n:::\n\n<!-- ### Cadenas formateadas (`format()`) -->\n\n<!-- - `c.format(valores)`: Devuelve la cadena `c` tras sustituir los valores de la secuencia `valores` en los marcadores de posición de `c`. Los marcadores de posición se indican mediante llaves `{}` en la cadena `c`, y el reemplazo de los valores se puede realizar por posición, indicando en número de orden del valor dentro de las llaves, o por nombre, indicando el nombre del valor, siempre y cuando los valores se pasen con el formato `nombre = valor`. -->\n\n<!-- ```python -->\n<!-- >>> 'Un {} vale {} {}'.format('€', 1.12, '$') -->\n<!-- 'Un € vale 1.12 $' -->\n<!-- >>> 'Un {2} vale {1} {0}'.format('€', 1.12, '$') -->\n<!-- 'Un $ vale 1.12 €' -->\n<!-- >>> 'Un {moneda1} vale {cambio} {moneda2}'.format(moneda1 = '€', cambio = 1.12, moneda2 = '$') -->\n<!-- 'Un € vale 1.12 $' -->\n<!-- ``` -->\n\n<!-- Los marcadores de posición, a parte de indicar la posición de los valores de reemplazo, pueden indicar también el formato de estos. Para ello se utiliza la siguiente sintaxis: -->\n\n<!-- - `{:n}` : Alinea el valor a la izquierda rellenando con espacios por la derecha hasta los `n` caracteres. -->\n<!-- - `{:>n}` : Alinea el valor a la derecha rellenando con espacios por la izquierda hasta los `n` caracteres. -->\n<!-- - `{:^n}` : Alinea el valor en el centro rellenando con espacios por la izquierda y por la derecha hasta los `n` caracteres. -->\n<!-- - `{:nd}` : Formatea el valor como un número entero con `n` caracteres rellenando con espacios blancos por la izquierda. -->\n<!-- - `{:n.mf}` : Formatea el valor como un número real con un tamaño de `n` caracteres (incluído el separador de decimales) y `m` cifras decimales, rellenando con espacios blancos por la izquierda. -->\n\n<!-- ```python -->\n<!-- >>> 'Hoy es {:^10}, mañana {:10} y pasado {:>10}'.format('lunes', 'martes', 'miércoles') -->\n<!-- 'Hoy es   lunes   , mañana martes     y pasado  miércoles' -->\n<!-- >>> 'Cantidad {:5d}'.format(12)' -->\n<!-- 'Cantidad    12' -->\n<!-- >>> 'Pi vale {:8.4f}'.format(3.141592) -->\n<!-- 'Pi vale   3.1416' -->\n<!-- ``` -->\n\n## Operaciones con datos lógicos o booleanos\n\n### Operadores lógicos\n\nA la hora de comparar valores lógicos R asocia a `TRUE` el valor 1 y a `FALSE` el valor 0.\n\n- `x == y`: Devuelve `TRUE` si los booleanos `x` y `y` son iguales, y `FALSE` en caso contrario.\n- `x < y`: Devuelve `TRUE` si el booleano `x` es menor que el booleano `y`, y `FALSE` en caso contrario. \n- `x <= y`: Devuelve `TRUE` si el booleano `x` es menor o igual que el booleano `y`, y `FALSE` en caso contrario. \n- `x > y`: Devuelve `TRUE` si el booleano `x` es mayor que el booleano `y`, y `FALSE` en caso contrario. \n- `x >= y`: Devuelve `TRUE` si el booleano `x` es mayor o igual que el booleano `y`, y `FALSE` en caso contrario.\n- `x != y`: Devuelve `TRUE` si el booleano `x` es distinto que el booleano `y`, y `FALSE` en caso contrario.\n- Negación `!b`: Devuelve `TRUE` si el booleano `b` es `FALSE`, y `FALSE` si es `TRUE`.\n- Conjunción `x & y`: Devuelve `TRUE` si los booleanos `x`, y `y` son `TRUE` y `FALSE` en caso contrario.\n- Disyunción `x | y`: Devuelve `TRUE` si alguno de los booleanos `x` o `y` son `TRUE`, y `FALSE` en caso contrario.\n\n\n#### Tabla de verdad {-}\n\n|   `x`   |   `y`   | `!x` | `x & y` | `x | y` |\n| :-----: | :-----: | :-----: | :-------: | :------: |\n| `FALSE` | `FALSE` | `TRUE`  |  `FALSE`  | `FALSE`  |\n| `FALSE` | `TRUE`  | `TRUE`  |  `FALSE`  |  `TRUE`  |\n| `TRUE`  | `FALSE` | `FALSE` |  `FALSE`  |  `TRUE`  |\n| `TRUE`  | `TRUE`  | `FALSE` |  `TRUE`   |  `TRUE`  |\n\n:::{#exm-operadores-logicos}\nA continuación se muestran varios ejemplos de operaciones lógicas con booleanos.\n\n\n::: {.cell hash='02-tipos-datos-simples_cache/pdf/unnamed-chunk-8_98078be9bb775d5bc619bb3bbb552a3c'}\n\n```{.r .cell-code}\n!TRUE\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] FALSE\n```\n:::\n\n```{.r .cell-code}\nFALSE | TRUE\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n\n```{.r .cell-code}\nFALSE | FALSE\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] FALSE\n```\n:::\n\n```{.r .cell-code}\nTRUE & FALSE\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] FALSE\n```\n:::\n\n```{.r .cell-code}\nTRUE & TRUE\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n:::\n\n\n:::\n\n## Variables \n\nUna variable es un identificador ligado a un valor.\n\n:::{.callout-note}\n## Reglas para nombrar variables\n\n- Comienzan siempre por una letra o punto, seguida de otras letras, números, puntos o guiones bajos. Si empieza por punto no puede seguirle un número.\n- No se pueden utilizarse palabras reservadas del lenguaje.\n:::\n\nA diferencia de otros lenguajes de programación, las variables no tienen asociado un tipo de dato y no es necesario declararlas antes de usarlas (tipado dinámico).\n\nPara asignar un valor a una variable se utiliza el operador de asignación `<-`:\n\n- `x <- y`: Asigna el valor `y` a la variable `x`.\n\nAunque es menos común también se puede utilizar el operador `=`.\n\nSe puede crear una variable sin ningún valor asociado asignándole el valor `NULL`.\n\nUna vez definida una variable, puede utilizarse en cualquier expresión donde tenga sentido el valor que tiene asociado.\n\nSi una variable ya no va a usarse, es posible eliminarla y liberar el espacio que ocupan sus datos asociados con la siguiente función:\n\n- `rm(x)`: Elimina la variable `x`.\n\n:::{#exm-variables}\nA continuación se muestran varios ejemplos de asignaciones de valores a variables.\n\n\n::: {.cell hash='02-tipos-datos-simples_cache/pdf/unnamed-chunk-9_4177e4a26e8bae4c796482bec6059f4f'}\n\n```{.r .cell-code}\nx <- 3\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 3\n```\n:::\n\n```{.r .cell-code}\ny <- x + 2\ny\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 5\n```\n:::\n\n```{.r .cell-code}\n# Valor no definido\nx <- NULL\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nNULL\n```\n:::\n\n```{.r .cell-code}\n# Eliminar y\nrm(y)\n# A partir de aquí, una llamada a y produce un error.\n```\n:::\n\n\n:::\n\n\n### Prioridad de los operadores\n\nAl evaluar una expresiones R utiliza el siguiente orden de prioridad de evaluación:\n\n|       |                        |\n| :---: | :--------------------: |\n|   1   | Funciones predefinidas |\n|   2   |       Potencias (`^`)   |     |\n|   3   | Productos y cocientes (`*`, `/`, `%%`) |\n|   4   |     Sumas y restas  (`+`, `-`)    |\n|   5    |  Operadores relacionales (`==`, `>`, `<`, `>=`, `<=`, `!=`) |\n| 6 | Negación (`!`) |\n| 7 | Conjunción (`&`) |\n| 8 | Disyunción (`|`) |\n| 9 | Asignación (`<-`) |\n\nSe puede saltar el orden de evaluación utilizando paréntesis `( )`.\n\n:::{#exm-prioridad-evaluacion}\nA continuación se muestran varios ejemplos de evaluación de expresiones.\n\n\n::: {.cell hash='02-tipos-datos-simples_cache/pdf/unnamed-chunk-10_635c8b94cb0d861350ef5662534b581c'}\n\n```{.r .cell-code}\n4 + 8 / 2 ^ 2\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 6\n```\n:::\n\n```{.r .cell-code}\n4 + (8 / 2) ^ 2\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 20\n```\n:::\n\n```{.r .cell-code}\n(4 + 8) / 2 ^ 2\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 3\n```\n:::\n\n```{.r .cell-code}\n(4 + 8 / 2) ^ 2\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 64\n```\n:::\n\n```{.r .cell-code}\nx <- 2 \ny <- 3\nz <- ! x + 1 > y & y * 2  < x ^ 3\nz\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n:::\n\n\n:::\n\n\n## Ejercicios\n\n:::{#exr-tipos-datos-1}\nSe dispone de los siguientes datos de una persona:\n\n| Variable | Valor |\n|:--:|:--:|\n| edad | 20 |\n| estatura | 165 |\n| peso | 60 |\n| sexo | mujer |\n\na.  Declarar las variables anteriores y asignarles los valores correspondientes.\n\n    :::{.callout-note collapse=\"true\"}\n    ## Solución \n\n\n    ::: {.cell hash='02-tipos-datos-simples_cache/pdf/unnamed-chunk-11_f7e63ff3d486962a5b78747dbcfede38'}\n    \n    ```{.r .cell-code}\n    # Declaración de variables\n    edad <- 20\n    estatura <- 165\n    peso <- 60\n    sexo <- \"mujer\"\n    ```\n    :::\n\n\n    :::\n\na.  Definir la variable numérica imc con el índice de masa corporal aplicando la siguiente fórmula a las variables anteriores: \n\n    $$\n    \\mbox{imc} = \\frac{\\mbox{peso (kg)}}{\\mbox{estatura (m)}^2}\n    $$\n\n    :::{.callout-note collapse=\"true\"}\n    ## Solución \n\n\n    ::: {.cell hash='02-tipos-datos-simples_cache/pdf/unnamed-chunk-12_6a6b6e84439e940fa0cc3a6d27492820'}\n    \n    ```{.r .cell-code}\n    # Cálculo del índice de masa corporal\n    imc <- peso / (estatura / 100) ^ 2\n    imc\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    ```\n    [1] 22.03857\n    ```\n    :::\n    :::\n\n\n    :::\n\na.  Mostrar por pantalla el indice de masa corporal calculado en el apartado anterior redondeado a dos decimales y con sus unidades en mayúsculas.\n\n    :::{.callout-note collapse=\"true\"}\n    ## Solución \n\n\n    ::: {.cell hash='02-tipos-datos-simples_cache/pdf/unnamed-chunk-13_71cf01abef924c5f916c7eaffd06a4f7'}\n    \n    ```{.r .cell-code}\n    # Salida por pantalla\n    paste(\"Índice de masa corporal: \", round(imc,2), toupper(\"KG/M²\"))\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    ```\n    [1] \"Índice de masa corporal:  22.04 KG/M²\"\n    ```\n    :::\n    :::\n\n\n    :::\n\na.  Definir la variable booleana obesa con el valor correspondiente a la siguiente condición: ser mujer y no tener una edad superior a 60 y tener un índice de masa corporal mayor o igual que 30. ¿Es esta persona obesa?\n\n    :::{.callout-note collapse=\"true\"}\n    ## Solución \n\n\n    ::: {.cell hash='02-tipos-datos-simples_cache/pdf/unnamed-chunk-14_3eb9eeba9f6e9ac60f23a996d5eb34a4'}\n    \n    ```{.r .cell-code}\n    # Cálculo de la obesidad\n    obesa <- sexo == \"mujer\" & ! edad > 60 & imc >= 30\n    obesa\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    ```\n    [1] FALSE\n    ```\n    :::\n    :::\n\n\n    :::\n:::",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {
      "knitr": [
        "{\"type\":\"list\",\"attributes\":{},\"value\":[]}"
      ]
    },
    "preserve": null,
    "postProcess": false
  }
}