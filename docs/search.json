[
  {
    "objectID": "index.html#propósito-de-este-manual",
    "href": "index.html#propósito-de-este-manual",
    "title": "Curso básico de análisis de datos con R",
    "section": "Propósito de este manual",
    "text": "Propósito de este manual\nEste manual proporciona una introducción amigable al lenguaje de programación R para aquellas personas interesadas en utilizar este lenguaje para el análisis de datos.\nEl manual empieza con los conceptos básicos del lenguaje de programación R pero enseguida aborda su uso para la visualización y el análisis estadístico de datos, haciendo un recorrido por los test estadísticos más comunes.\nLo más interesante de este manual es la multitud de ejemplos que ilustran el uso de las técnicas estadísticas presentadas, así como los problemas propuestos.\nEl manual no aborda los fundamentos matemáticos de los análisis estadísticos presentados, aunque si explica brevemente cuándo deben usarse y cuándo no, así como las interpretaciones de los resultados obtenidos en los ejemplos. Si alguien está interesado en profundizar en los detalles matemáticos, puede visitar esta página.\nNo es un curso de programación en R, sino de uso de sus funciones predefinidas y de los paquetes más habituales para el análisis de datos.\nPara cualquier comentario o sugerencia sobre este manual escriba al autor (asalber@ceu.es)."
  },
  {
    "objectID": "index.html#licencia",
    "href": "index.html#licencia",
    "title": "Curso básico de análisis de datos con R",
    "section": "Licencia",
    "text": "Licencia\nEsta obra está bajo una licencia Reconocimiento – No comercial – Compartir bajo la misma licencia 3.0 España de Creative Commons. Para ver una copia de esta licencia, visite https://creativecommons.org/licenses/by-nc-sa/3.0/es/.\nCon esta licencia eres libre de:\n\nCopiar, distribuir y mostrar este trabajo.\nRealizar modificaciones de este trabajo.\n\nBajo las siguientes condiciones:\n\nReconocimiento. Debe reconocer los créditos de la obra de la manera especificada por el autor o el licenciador (pero no de una manera que sugiera que tiene su apoyo o apoyan el uso que hace de su obra).\nNo comercial. No puede utilizar esta obra para fines comerciales.\nCompartir bajo la misma licencia. Si altera o transforma esta obra, o genera una obra derivada, sólo puede distribuir la obra generada bajo una licencia idéntica a ésta.\n\nAl reutilizar o distribuir la obra, tiene que dejar bien claro los términos de la licencia de esta obra.\nEstas condiciones pueden no aplicarse si se obtiene el permiso del titular de los derechos de autor.\nNada en esta licencia menoscaba o restringe los derechos morales del autor."
  },
  {
    "objectID": "01-intro.html#instalación-de-r",
    "href": "01-intro.html#instalación-de-r",
    "title": "1  Introducción a R",
    "section": "1.1 Instalación de R",
    "text": "1.1 Instalación de R\nR puede descargarse desde el sitio web oficial de R o desde el repositorio principal de paquetes de R CRAN. Basta con descargar el archivo de instalación correspondiente al sistema operativo de nuestro ordenador y realizar la instalación como cualquier otro programa.\nEl intérprete de R se arranca desde la terminal, aunque en Windows incorpora su propia aplicación, pero es muy básica. En general, para trabajos serios, conviene utilizar un entorno de desarrollo para R."
  },
  {
    "objectID": "01-intro.html#entornos-de-desarrollo",
    "href": "01-intro.html#entornos-de-desarrollo",
    "title": "1  Introducción a R",
    "section": "1.2 Entornos de desarrollo",
    "text": "1.2 Entornos de desarrollo\nPor defecto el entorno de trabajo de R es en línea de comandos, lo que significa que los cálculos y los análisis se realizan mediante comandos o instrucciones que el usuario teclea en una ventana de texto. No obstante, existen distintas interfaces gráficas de usuario que facilitan su uso, sobre todo para usuarios noveles. Algunas de ellas, como las que se enumeran a continuación, son completos entornos de desarrollo que facilitan la gestión de cualquier proyecto:\n\nRStudio. Probablemente el entorno de desarrollo más extendido para programar con R ya que incorpora multitud de utilidades para facilitar la programación con R.\nRKWard. Es otra otro de los entornos de desarrollo más completos que además incluye a posibilidad de añadir nuevos menús y cuadros de diálogo personalizados.\nVisual Studio Code. Es un entorno de desarrollo de propósito general ampliamente extendido. Aunque no es un entorno de desarrollo específico para R, incluye una extensión con utilidades que facilitan mucho el desarrollo con R."
  },
  {
    "objectID": "02-tipos-datos-simples.html#conversión-de-tipos",
    "href": "02-tipos-datos-simples.html#conversión-de-tipos",
    "title": "2  Tipos de datos simples",
    "section": "2.1 Conversión de tipos",
    "text": "2.1 Conversión de tipos\nEn muchas ocasiones es posible convertir un dato de un tipo a otro distinto. Para ello se usan las siguientes funciones:\n\nas.numeric(x): Convierte el dato de x al tipo numeric siempre que sea posible o tenga sentido la conversión. Para convertir una cadena en un número, la cadena tiene que representar un número. El valor lógico TRUE se convierte en 1 y el FALSE en 0.\nas.integer(x): Convierte el dato de x al tipo integer siempre que sea posible o tenga sentido la conversión. Para convertir una cadena en un número entero, la cadena tiene que representar un número entero. El valor lógico TRUE se convierte en 1 y el FALSE en 0.\nas.character(x): Convierte el tipo de dato de x al tipo character simplemente añadiendo comillas.\nas.logical(x): Convierte el tipo de dato de x al tipo lógico. Para datos numéricos, el 0 se convierte en FALSE y cualquier otro número en TRUE. Para cadenas se obtiene NA excepto para las cadenas \"TRUE\" y \"true\" que se convierten a TRUE y las cadenas \"FALSE\" y \"false\" que se convierten a FALSE.\n\nEl tipo NA no se puede convertir a ningún otro tipo pues representa la ausencia del dato. Lo mismo ocurre con NULL."
  },
  {
    "objectID": "02-tipos-datos-simples.html#operaciones-con-números",
    "href": "02-tipos-datos-simples.html#operaciones-con-números",
    "title": "2  Tipos de datos simples",
    "section": "2.2 Operaciones con números",
    "text": "2.2 Operaciones con números\n\n2.2.1 Operadores aritméticos\nLos siguientes operadores permiten realizar las clásicas operaciones aritméticas entre datos numéricos:\n\nx + y: Devuelve la suma de x e y.\nx - y: Devuelve la resta de x e y.\nx * y: Devuelve el producto de x e y.\nx / y: Devuelve el cociente de x e y.\n\nx %% y: Devuelve el resto de la división entera de x e y.\n\nx ^ y: Devuelve la potencia x elevado a y.\n\n\nEjemplo 2.2 A continuación se muestran varios ejemplos de operaciones aritméticas.\n\n2 + 3\n\n[1] 5\n\n5 * -2\n\n[1] -10\n\n5 / 2\n\n[1] 2.5\n\n1 / 0\n\n[1] Inf\n\n5 %% 2\n\n[1] 1\n\n2 ^ 3\n\n[1] 8\n\n\n\n\n\n2.2.2 Operadores relacionales\nComparan dos números y devuelven un valor lógico.\n\nx == y : Devuelve TRUE si el número x es igual que el número y, y FALSE en caso contrario.\nx > y : Devuelve TRUE si el número x es mayor que el número y, y FALSE en caso contrario.\nx < y : Devuelve TRUE si el número x es menor que el número y, y FALSE en caso contrario.\nx >= y : Devuelve TRUE si el número x es mayor o igual que el número y, y FALSE en caso contrario.\nx <= y : Devuelve TRUE si el número x es menor o igual a que el número y, y FALSE en caso contrario.\nx != y : Devuelve TRUE si el número x es distinto del número y, y FALSE en caso contrario.\n\n\nEjemplo 2.3 A continuación se muestran varios ejemplos de operaciones relacionales.\n\n3 == 3\n\n[1] TRUE\n\n3.1 <= 3\n\n[1] FALSE\n\n4 > 3\n\n[1] TRUE\n\n-1 != 1\n\n[1] TRUE\n\n5 %% 2\n\n[1] 1\n\n2 ^ 3\n\n[1] 8\n\n(2 + 3) ^ 2\n\n[1] 25"
  },
  {
    "objectID": "02-tipos-datos-simples.html#operaciones-con-cadenas",
    "href": "02-tipos-datos-simples.html#operaciones-con-cadenas",
    "title": "2  Tipos de datos simples",
    "section": "2.3 Operaciones con cadenas",
    "text": "2.3 Operaciones con cadenas\n\n2.3.1 Funciones de cadenas\nExisten muchas funciones para cadenas de texto pero las más comunes son:\n\nnchar(c): Devuelve un número entero con el número de caracteres de la cadena.\npaste(x, y, ..., sep=s): Concatena las cadenas x, y, etc. separándolas por la cadena s. Por defecto la cadena de separación es un espacio en blanco.\nsubstr(c, start=i, stop=j): Devuelve la subcadena de la cadena c desde la posición i hasta la posición j. El primer carácter de una cadena ocupa la posición 1.\ntolower(c): Devuelve la cadena que resulta de convertir la cadena c a minúsculas.\ntoupper(c): Devuelve la cadena que resulta de convertir la cadena c a mayúsculas.\n\n\nEjemplo 2.4 A continuación se muestran varios ejemplos de operaciones con cadenas de texto.\n\nnchar(\"Me gusta R\")\n\n[1] 10\n\npaste(\"Me\", \"gusta\", \"R\")\n\n[1] \"Me gusta R\"\n\npaste(\"Me\", \"gusta\", \"R\", sep = \"-\")\n\n[1] \"Me-gusta-R\"\n\npaste(\"Me\", \"gusta\", \"R\", sep = \"\")\n\n[1] \"MegustaR\"\n\nsubstr(\"Me gusta R\", 4, 8)\n\n[1] \"gusta\"\n\ntolower(\"Me gusta R\")\n\n[1] \"me gusta r\"\n\ntoupper(\"Me gusta R\")\n\n[1] \"ME GUSTA R\"\n\n\n\n\n\n2.3.2 Operaciones de comparación de cadenas\n\nx == y : Devuelve TRUE si la cadena x es igual que la cadena y, y FALSE en caso contrario.\nx > y : Devuelve TRUE si la cadena x sucede a la cadena y, y FALSE en caso contrario.\nx < y : Devuelve TRUE si la cadena x antecede a la cadena y, y FALSE en caso contrario.\nx >= y : Devuelve TRUE si la cadena x sucede o es igual a la cadena y, y FALSE en caso contrario.\nx <= y : Devuelve TRUE si la cadena x antecede o es igual a la cadena y, y FALSE en caso contrario.\nx != y : Devuelve TRUE si la cadena x es distinta de la cadena y, y FALSE en caso contrario.\n\n Utilizan el orden alfabético, las minúsculas van antes que las mayúsculas, y los números antes que las letras.\n\nEjemplo 2.5 A continuación se muestran varios ejemplos de operaciones de comparación de cadenas.\n\n\"R\" == \"R\"\n\n[1] TRUE\n\n\"R\" == \"r\"\n\n[1] FALSE\n\n\"uno\" < \"dos\"\n\n[1] FALSE\n\n\"A\" > \"a\"\n\n[1] TRUE\n\n\"\" < \"R\"\n\n[1] TRUE"
  },
  {
    "objectID": "02-tipos-datos-simples.html#operaciones-con-datos-lógicos-o-booleanos",
    "href": "02-tipos-datos-simples.html#operaciones-con-datos-lógicos-o-booleanos",
    "title": "2  Tipos de datos simples",
    "section": "2.4 Operaciones con datos lógicos o booleanos",
    "text": "2.4 Operaciones con datos lógicos o booleanos\n\n2.4.1 Operadores lógicos\nA la hora de comparar valores lógicos R asocia a TRUE el valor 1 y a FALSE el valor 0.\n\nx == y: Devuelve TRUE si los booleanos x y y son iguales, y FALSE en caso contrario.\nx < y: Devuelve TRUE si el booleano x es menor que el booleano y, y FALSE en caso contrario.\nx <= y: Devuelve TRUE si el booleano x es menor o igual que el booleano y, y FALSE en caso contrario.\nx > y: Devuelve TRUE si el booleano x es mayor que el booleano y, y FALSE en caso contrario.\nx >= y: Devuelve TRUE si el booleano x es mayor o igual que el booleano y, y FALSE en caso contrario.\nx != y: Devuelve TRUE si el booleano x es distinto que el booleano y, y FALSE en caso contrario.\nNegación !b: Devuelve TRUE si el booleano b es FALSE, y FALSE si es TRUE.\nConjunción x & y: Devuelve TRUE si los booleanos x, y y son TRUE y FALSE en caso contrario.\nDisyunción x | y: Devuelve TRUE si alguno de los booleanos x o y son TRUE, y FALSE en caso contrario.\n\n\nTabla de verdad\n\n\n\nx\ny\n!x\nx & y\nx | y\n\n\n\n\nFALSE\nFALSE\nTRUE\nFALSE\nFALSE\n\n\nFALSE\nTRUE\nTRUE\nFALSE\nTRUE\n\n\nTRUE\nFALSE\nFALSE\nFALSE\nTRUE\n\n\nTRUE\nTRUE\nFALSE\nTRUE\nTRUE\n\n\n\n\nEjemplo 2.6 A continuación se muestran varios ejemplos de operaciones lógicas con booleanos.\n\n!TRUE\n\n[1] FALSE\n\nFALSE | TRUE\n\n[1] TRUE\n\nFALSE | FALSE\n\n[1] FALSE\n\nTRUE & FALSE\n\n[1] FALSE\n\nTRUE & TRUE\n\n[1] TRUE"
  },
  {
    "objectID": "02-tipos-datos-simples.html#variables",
    "href": "02-tipos-datos-simples.html#variables",
    "title": "2  Tipos de datos simples",
    "section": "2.5 Variables",
    "text": "2.5 Variables\nUna variable es un identificador ligado a algún valor.\n\n\n\n\n\n\nReglas para nombrar variables\n\n\n\n\nComienzan siempre por una letra o punto, seguida de otras letras, números, puntos o guiones bajos. Si empieza por punto no puede seguirle un número.\nNo se pueden utilizarse palabras reservadas del lenguaje.\n\n\n\nA diferencia de otros lenguajes de programación, las variables no tienen asociado un tipo y no es necesario declararlas antes de usarlas (tipado dinámico).\nPara asignar un valor a una variable se utiliza el operador de asignación <-:\n\nx <- y: Asigna el valor y a la variable x.\n\nAunque es menos común también se puede utilizar el operador =.\nSe puede crear una variable sin ningún valor asociado asignándole el valor NULL.\nUna vez definida una variable, puede utilizarse en cualquier expresión donde tenga sentido el valor que tiene asociado.\nSi una variable ya no va a usarse, es posible eliminarla y liberar el espacio que ocupan sus datos asociados con la siguiente función:\n\nrm(x): Elimina la variable x.\n\n\nEjemplo 2.7 A continuación se muestran varios ejemplos de asignaciones de valores a variables.\n\nx <- 3\nx\n\n[1] 3\n\ny <- x + 2\ny\n\n[1] 5\n\n# Valor no definido\nx <- NULL\nx\n\nNULL\n\n# Eliminar y\nrm(y)\n# A partir de aquí, una llamada a y produce un error.\n\n\n\n2.5.1 Prioridad de los operadores\nAl evaluar una expresiones R utiliza el siguiente orden de prioridad de evaluación:\n\n\n\n1\nFunciones predefinidas\n\n\n2\nPotencias (^)\n\n\n3\nProductos y cocientes (*, /, %%)\n\n\n4\nSumas y restas (+, -)\n\n\n5\nOperadores relacionales (==, >, <, >=, <=, !=)\n\n\n6\nNegación (!)\n\n\n7\nConjunción (&)\n\n\n8\nDisyunción (|)\n\n\n9\nAsignación (<-)\n\n\n\nSe puede saltar el orden de evaluación utilizando paréntesis ( ).\n\nEjemplo 2.8 A continuación se muestran varios ejemplos de evaluación de expresiones.\n\n4 + 8 / 2 ^ 2\n\n[1] 6\n\n4 + (8 / 2) ^ 2\n\n[1] 20\n\n(4 + 8) / 2 ^ 2\n\n[1] 3\n\n(4 + 8 / 2) ^ 2\n\n[1] 64\n\nx <- 2 \ny <- 3\nz <- ! x + 1 > y & y * 2  < x ^ 3\nz\n\n[1] TRUE"
  },
  {
    "objectID": "02-tipos-datos-simples.html#ejercicios",
    "href": "02-tipos-datos-simples.html#ejercicios",
    "title": "2  Tipos de datos simples",
    "section": "2.6 Ejercicios",
    "text": "2.6 Ejercicios\n\nEjercicio 2.1 Se dispone de los siguientes datos de una persona:\n\n\n\nVariable\nValor\n\n\n\n\nedad\n20\n\n\nestatura\n165\n\n\npeso\n60\n\n\nsexo\nmujer\n\n\n\n\nDeclarar las variables anteriores y asignarles los valores correspondientes.\n\n\n\n\n\n\n\nSolución\n\n\n\n\n\n\n# Declaración de variables\nedad <- 20\nestatura <- 165\npeso <- 60\nsexo <- \"mujer\"\n\n\n\n\n\nDefinir la variable numérica imc con el índice de masa corporal aplicando la siguiente fórmula a las variables anteriores:\n\n\\[\\mbox{imc} = \\frac{\\mbox{peso (kg)}}{\\mbox{estatura (m)}^2}\\]\n\n\n\n\n\n\nSolución\n\n\n\n\n\n\n# Cálculo del índice de masa corporal\nimc <- peso / (estatura / 100) ^ 2\nimc\n\n[1] 22.03857\n\n\n\n\n\n\nDefinir la variable booleana obesa con el valor correspondiente a la siguiente condición: ser mujer y no tener una edad superior a 60 y tener un índice de masa corporal mayor o igual que 30. ¿Es esta persona obesa?\n\n\n\n\n\n\n\n\nSolución\n\n\n\n\n\n\n# Cálculo de la obesidad\nobesa <- sexo == \"mujer\" & ! edad > 60 & imc >= 30\nobesa\n\n[1] FALSE"
  },
  {
    "objectID": "03-tipos-datos-estructurados.html#vectores",
    "href": "03-tipos-datos-estructurados.html#vectores",
    "title": "3  Tipos de datos estructurados",
    "section": "3.1 Vectores",
    "text": "3.1 Vectores\nEl vector es el tipo de dato estructurado más básicos en R. Un vector es una colección ordenada de elementos del mismo tipo.\n\n3.1.1 Creación de vectores\nPara construir un vector se utiliza la función de combinación c():\n\nc(x1, x2, ...): Devuelve el vector formado por los elementos x1, x2, etc.\n\nTambién es posible utilizar el operador : para generar un vector de números enteros consecutivos:\n\nx:y: Devuelve el vector de números enteros consecutivos desde x hasta y.\n\n\nEjemplo 3.1 A continuación se muestran varios ejemplos de construcción de vectores.\n\nc(1, 2, 3)\n\n[1] 1 2 3\n\nc(\"uno\", \"dos\", \"tres\")\n\n[1] \"uno\"  \"dos\"  \"tres\"\n\n# Vector vacío\nc()\n\nNULL\n\n# Vector con elementos perdidos\nc(1, NA, 3)\n\n[1]  1 NA  3\n\n# Vector de números enteros consecutivos del 2 al 6\n2:6\n\n[1] 2 3 4 5 6\n\n\n\n\n3.1.1.1 Vectores con nombres\nEs posible asignar un nombre a cada elemento de un vector. Los nombres son etiquetas de texto que se asocian a cada elemento. Para asociar un nombre a un elemento se utiliza la sintaxis nombre = valor, donde nombre es una cadena de caracteres y valor es el elemento del vector.\n\nEjemplo 3.2 A continuación se muestra un ejemplo de creación de un vector con nombres.\n\nc(\"Matemáticas\" = 8.2, \"Física\" = 6.5, \"Economía\" = 4.5)\n\nMatemáticas      Física    Economía \n        8.2         6.5         4.5 \n\n\n\nPara acceder a los nombres de un vector se utiliza la siguiente función:\n\nnames(x): Devuelve un vector de cadenas de caracteres con los nombres de los elementos del vector x.\n\n\nEjemplo 3.3 A continuación se muestra un ejemplo de acceso a los nombres de un vector.\n\nnotas <- c(\"Matemáticas\" = 8.2, \"Física\" = 6.5, \"Economía\" = 4.5)\nnames(notas)\n\n[1] \"Matemáticas\" \"Física\"      \"Economía\"   \n\n\n\n\n\n\n3.1.2 Tamaño de un vector\nEl número de elementos de un vector es su tamaño y puede averiguarse con la siguiente función.\n\nlenght(x): Devuelve el número de elementos del vector x.\n\n\nEjemplo 3.4 A continuación se muestran varios ejemplos de la obtención del tamaño de un vector.\n\nlength(c(1, 2, 3))\n\n[1] 3\n\nlength(c())\n\n[1] 0\n\n\n\n\n\n3.1.3 Coerción de elementos\nPuesto que los elementos de un vector tienen que ser del mismo tipo, cuando se crea un vector con datos de distintos tipos, la función c() los convertirá al mismo tipo, lo que se conoce como coerción de tipos. La coerción se produce de los tipos menos flexibles a los más flexibles: logical < integer < double < character.\n\nEjemplo 3.5 A continuación se muestran varios ejemplos de coerciones.\n\nc(1, 2.5)\n\n[1] 1.0 2.5\n\nc(FALSE, TRUE, 2)\n\n[1] 0 1 2\n\nc(FALSE, TRUE, 2, \"tres\")\n\n[1] \"FALSE\" \"TRUE\"  \"2\"     \"tres\" \n\n\n\n\n\n3.1.4 Acceso a los elementos de un vector\nPara acceder a los elementos de un vector se utiliza un índice. Como veremos a continuación, este índice puede ser entero, lógico o de cadena de caracteres y se indica siempre entre corchetes [ ] a continuación del vector.\n\n3.1.4.1 Acceso mediante un índice entero\nLos elementos de un vector están ordenados y el acceso más simple a ellos es mediante su número de orden, es decir, indicando entre corchetes [ ] el entero que corresponde a su número de orden. Se puede acceder simultáneamente a varios elementos mediante un vector con sus números de orden. Por otro lado, también es posible usar enteros negativos y en tal caso se obtendrán todos los elementos del vector excepto los que ocupan las posiciones correspondientes al valor absoluto de los índices negativos. Esta es la forma más habitual de eliminar elementos de un vector.\n\n\n\n\n\n\nAdvertencia\n\n\n\nEn R los índices enteros para acceder a los elementos de un vector comienzan en 1, a diferencia de otros lenguajes de programación que empiezan en 0.\n\n\n\nEjemplo 3.6 A continuación se muestran varios ejemplos de acceso a los elementos de un vector mediante índices enteros.\n\nx <- c(2,4,6,8,10)\n# Acceso al elemento que está en la tercera posición\nx[3]\n\n[1] 6\n\n# Acceso a los elementos de las posiciones 2 y 4\nx[c(2, 4)]\n\n[1] 4 8\n\n# Acceso a los elementos de la posición 2 a la 4\nx[2:4]\n\n[1] 4 6 8\n\n# Acceso a todos los elementos excepto el primero y el cuarto\nx[c(-1, -4)]\n\n[1]  4  6 10\n\n\n\n\n\n3.1.4.2 Acceso mediante un índice lógico\nCuando se utiliza un índice lógico, se obtienen los elementos correspondientes a las posiciones donde está el valor booleano TRUE.\n\nEjemplo 3.7 A continuación se muestran varios ejemplos de acceso a los elementos de un vector mediante índices lógicos.\n\nx <- c(2,4,6,8,10)\n# Acceso al elemento que está en la tercera posición\nx[c(F,F,T,F,F)]\n\n[1] 6\n\n# Acceso a los elementos de las posiciones 2 y 4\nx[c(F,T,F,T,F)]\n\n[1] 4 8\n\n\n\nEsta forma de acceder es útil cuando se genera el vector de índices mediante operadores relacionales. Cuando se aplica un operador relacional a un vector se obtiene otro vector lógico que resulta de aplicar el operador relacional a cada uno de los elementos del vector. De esta manera se puede realizar filtros para obtener los elementos de un vector que cumplen una determinada condición.\n\nEjemplo 3.8 A continuación se muestran varios ejemplos de acceso a los elementos de un vector mediante condiciones.\n\nx <- 1:6\nx %% 2 == 0\n\n[1] FALSE  TRUE FALSE  TRUE FALSE  TRUE\n\n# Filtrado de los valores pares\nx[x %% 2 == 0]\n\n[1] 2 4 6\n\n# Filtrado de los valores pares menores que 5\nx[x %% 2 == 0 & x < 5]\n\n[1] 2 4\n\n\n\n\n\n3.1.4.3 Acceso mediante un índice de cadena\nSi los elementos de un vector tienen nombre, es posible acceder a ellos usando sus nombres como índices.\n\nEjemplo 3.9 A continuación se muestran varios ejemplos de acceso a los elementos de un vector mediante índices de cadena.\n\nnotas <- c(\"Matemáticas\" = 8.2, \"Física\" = 6.5, \"Economía\" = 4.5)\nnotas[\"Física\"]\n\nFísica \n   6.5 \n\nnotas[c(\"Matemáticas\", \"Economía\")]\n\nMatemáticas    Economía \n        8.2         4.5 \n\n\n\n\n\n\n3.1.5 Pertenencia a un vector\nPara comprobar si un valor en particular es un elemento de un vector se puede utilizar el operador %in%:\n\nx %in% y: Devuelve el booleano TRUE si x es un elemento del vector y, y FALSE en caso contrario.\n\n:::{#exm-pertenencia-vector} A continuación se muestran varios ejemplos de pertenencia de elementos a un vector.\n\nx <- 1:3\n2 %in% x\n\n[1] TRUE\n\n4 %in% x\n\n[1] FALSE\n\n\n\n\n3.1.6 Modificación de los elementos de un vector\nPara modificar uno o varios elementos de un vector basta con acceder a esos elementos y usar el operador de asignación para asignar nuevos valores.\n\nEjemplo 3.10 A continuación se muestran varios ejemplos de modificación de los elementos de un vector.\n\nx <- c(1, 2, 3)\nx[2] <- 0\nx\n\n[1] 1 0 3\n\nx[c(1, 3)] <- 1\nx\n\n[1] 1 0 1\n\n\n\n\n\n3.1.7 Añadir elementos a un vector\nPara añadir nuevos elementos a un vector pueden usarse las siguientes funciones:\n\nc(x, y): Devuelve el vector que resulta de añadir al vector x los elementos del vector y.\nappend(x, y, pos): Devuelve el vector que resulta de añadir al vector x los elementos del vector y, a continuación de la posición pos. El parámetro pos es opcional y si no se indica, los elementos de y se añaden al final de los de x.\n\n\nEjemplo 3.11 A continuación se muestran varios ejemplos de añadir nuevos elementos a un vector.\n\nx <- c(1, 2, 3)\nc(x, c(4, 5))\n\n[1] 1 2 3 4 5\n\nappend(x, c(4, 5), 2)\n\n[1] 1 2 4 5 3\n\n\n\n\n\n3.1.8 Eliminar elementos de un vector\nPara eliminar los elementos que ocupan una determinada posición se utiliza el operador de acceso, es decir, los corchetes [ ] pero con los índices correspondientes a las posiciones a eliminar, en negativo.\n\nEjemplo 3.12 A continuación se muestran varios ejemplos de eliminar elementos de un vector.\n\nx <- c(\"a\", \"b\", \"c\", \"d\", \"e\")\nx[-3]\n\n[1] \"a\" \"b\" \"d\" \"e\"\n\nx[-c(2,4)]\n\n[1] \"a\" \"c\" \"e\"\n\n\n\n\n\n3.1.9 Eliminación de un vector\nPara eliminar los elementos de un vector basta con asignar NULL a la variable que lo contiene, pero si se quiere liberar la memoria que ocupa la variable se utiliza la función rm().\n\n\n3.1.10 Operaciones aritméticas con vectores\n\n3.1.10.1 Operaciones aritméticas elemento a elemento\nPara vectores numéricos las operaciones aritméticas habituales se aplican elemento a elemento. Si los vectores tienen distinto tamaño, el tamaño del vector más pequeño se equipara al tamaño del mayor, reutilizando sus elementos, empezando por el primero.\n\nEjemplo 3.13 A continuación se muestran varios ejemplos de operaciones aritméticas con vectores numéricos.\n\nx <- c(1, 2, 3)\ny <- c(0, 1, -1)\nx + y\n\n[1] 1 3 2\n\nx * y\n\n[1]  0  2 -3\n\nx / y\n\n[1] Inf   2  -3\n\nx ^ y\n\n[1] 1.0000000 2.0000000 0.3333333\n\n\n\n\n\n3.1.10.2 Producto escalar de vectores\nPara calcular el producto escalar de dos vectores numéricos se utiliza el operador %*%. Si los vectores tienen distinto tamaño se produce un error.\n\nEjemplo 3.14 A continuación se muestra un ejemplo del producto escalar de dos vectores.\n\nx <- c(1, 2, 3)\ny <- c(0, 1, -1)\nx %*% y\n\n     [,1]\n[1,]   -1"
  },
  {
    "objectID": "03-tipos-datos-estructurados.html#factores",
    "href": "03-tipos-datos-estructurados.html#factores",
    "title": "3  Tipos de datos estructurados",
    "section": "3.2 Factores",
    "text": "3.2 Factores\n\n3.2.1 Operaciones con factores\nUn factor es una estructura de datos especial que se utiliza para representar categorías de variables cualitativas y por tanto puede tomar un conjunto finito de valores predefinidos conocido como niveles del factor.\nPara definir un factor se utiliza la siguiente función:\n\nfactor(x, levels = niveles): Crea un dato de tipo factor con los elementos del vector x. Los niveles del factor pueden indicarse mediante el parámetro levels, pasándole un vector con los valores posibles. Si no se indica el parámetro levels los niveles del factor se obtienen automáticamente a partir de los elementos del vector x (tantos niveles con valores distintos tenga).\n\nLos factores son en realidad vectores de números enteros a los que se le añade un atributo especial para indicar los niveles del factor.\n\nEjemplo 3.15 A continuación se muestran varios ejemplos de creación de factores.\n\nsexo <- factor(c(\"mujer\", \"hombre\", \"mujer\"))\nsexo\n\n[1] mujer  hombre mujer \nLevels: hombre mujer\n\nclass(sexo)\n\n[1] \"factor\"\n\nstr(sexo)\n\n Factor w/ 2 levels \"hombre\",\"mujer\": 2 1 2\n\ngrupo.sanguineo <- factor(c(\"B\", \"A\", \"A\"), levels = c(\"A\", \"B\", \"AB\", \"0\"), )\ngrupo.sanguineo\n\n[1] B A A\nLevels: A B AB 0\n\n\n\nEs posible establecer un orden entre los niveles de un factor añadiendo el parámetro ordered = TRUE a la función anterior. Esto es útil para representar categorías ordinales entre las que existe un orden natural.\n\nEjemplo 3.16 A continuación se muestra un ejemplo de creación de un factor ordenado.\n\nnivel.estudio <- factor(c(\"Secundarios\", \"Graduado\", \"Bachiller\"), levels = c(\"Sin estudios\", \"Primarios\", \"Secundarios\", \"Bachiller\", \"Graduado\"), ordered = TRUE)\nnivel.estudio\n\n[1] Secundarios Graduado    Bachiller  \nLevels: Sin estudios < Primarios < Secundarios < Bachiller < Graduado\n\n\n\nPara comprobar si una estructura es del tipo factor se utiliza la siguiente función:\n\nis.factor(x): Devuelve el booleano TRUE si x es del tipo factor, y FALSE en caso contrario.\n\n\n\n3.2.2 Acceso a los elementos de un factor\nSe puede acceder a los elementos de un factor de la misma manera que se accede a los elementos de un vector. Y para obtener sus niveles se utiliza la siguiente función:\n\nlevels(x): Devuelve un vector con los niveles del factor x.\n\n\nEjemplo 3.17 A continuación se muestran varios ejemplos de acceso a los elementos y los niveles de un factor.\n\nsexo <- factor(c(\"mujer\", \"hombre\", \"mujer\"))\nsexo[2]\n\n[1] hombre\nLevels: hombre mujer\n\nsexo[c(1, 2)]\n\n[1] mujer  hombre\nLevels: hombre mujer\n\nsexo[-2]\n\n[1] mujer mujer\nLevels: hombre mujer\n\nlevels(sexo)\n\n[1] \"hombre\" \"mujer\" \n\n\n\n\n\n3.2.3 Modificación de los elementos de un factor\nSe puede modificar los elementos de un factor de manera similar a como se modifican los elementos de un vector, es decir accediendo al elemento que se quiere modificar y asignándole un nuevo valor. La única diferencia con los vectores es que si el nuevo valor que se quiere asignar no está entre los niveles del factor, se obtiene el valor NA.\n\nEjemplo 3.18 A continuación se muestran varios de modificación de los elementos de un factor.\n\ngrupo.sanguineo <- factor(c(\"B\", \"A\", \"A\"), levels = c(\"A\", \"B\", \"AB\", \"0\"))\ngrupo.sanguineo\n\n[1] B A A\nLevels: A B AB 0\n\ngrupo.sanguineo[2] <- \"AB\"\ngrupo.sanguineo\n\n[1] B  AB A \nLevels: A B AB 0\n\ngrupo.sanguineo[1] <- \"C\"\n\nWarning in `[<-.factor`(`*tmp*`, 1, value = \"C\"): invalid factor level, NA\ngenerated\n\ngrupo.sanguineo\n\n[1] <NA> AB   A   \nLevels: A B AB 0\n\n\n\nObsérvese en el ejemplo anterior que cuando se intenta asignar un valor a un factor que no está entre sus niveles, se produce un error."
  },
  {
    "objectID": "03-tipos-datos-estructurados.html#listas",
    "href": "03-tipos-datos-estructurados.html#listas",
    "title": "3  Tipos de datos estructurados",
    "section": "3.3 Listas",
    "text": "3.3 Listas\nLas listas son colecciones ordenadas de elementos que pueden ser de distintos tipos. Los elementos de una lista también pueden ser de tipos estructurados (vectores o listas), lo que las convierte en el tipo de dato más versátil de R. Como veremos más adelante, otras estructuras de datos como los data frames o los propios modelos estadísticos se construyen usando listas.\n\n3.3.1 Creación de listas\nPara construir una lista se utiliza la función list():\n\nlist(x1, x2, ...): Devuelve la lista con los elementos x1, x2, etc.\n\n\nEjemplo 3.19 A continuación se muestran varios ejemplos de creación de listas.\n\nlist(1, \"dos\", TRUE)\n\n[[1]]\n[1] 1\n\n[[2]]\n[1] \"dos\"\n\n[[3]]\n[1] TRUE\n\n# Lista con vectores y listas\nx <- list(1, c(\"dos\", \"tres\"), list(4, \"cinco\"))\nx\n\n[[1]]\n[1] 1\n\n[[2]]\n[1] \"dos\"  \"tres\"\n\n[[3]]\n[[3]][[1]]\n[1] 4\n\n[[3]][[2]]\n[1] \"cinco\"\n\nstr(x)\n\nList of 3\n $ : num 1\n $ : chr [1:2] \"dos\" \"tres\"\n $ :List of 2\n  ..$ : num 4\n  ..$ : chr \"cinco\"\n\n# Lista vacía\nlist()\n\nlist()\n\n\n\n\n3.3.1.1 Listas con nombres\nAl igual que con los vectores, es posible asignar un nombre a cada uno de los elementos de una lista.\n\nEjemplo 3.20 A continuación se muestra un ejemplo de creación de una lista con nombres.\n\nlist(\"nombre\" = \"María\", \"edad\" = 21, \"dirección\" = list(\"calle\" = \"Delicias\", \"número\" = 24, \"municipio\" = \"Madrid\"))\n\n$nombre\n[1] \"María\"\n\n$edad\n[1] 21\n\n$dirección\n$dirección$calle\n[1] \"Delicias\"\n\n$dirección$número\n[1] 24\n\n$dirección$municipio\n[1] \"Madrid\"\n\n\n\nPara obtener los nombres de una lista se utiliza la siguiente función:\n\nnames(x): Devuelve un vector de cadenas de caracteres con los nombres de los elementos de la lista x.\n\n\nEjemplo 3.21 A continuación se muestra un ejemplo de acceso a los nombres de una lista.\n\npersona <- list(\"nombre\" = \"María\", \"edad\" = 21, \"dirección\" = list(\"calle\" = \"Delicias\", \"número\" = 24, \"municipio\" = \"Madrid\"))\nnames(persona)\n\n[1] \"nombre\"    \"edad\"      \"dirección\"\n\n\n\n\n\n\n3.3.2 Tamaño de una lista\nEl número de elementos de una lista es su tamaño y puede averiguarse con la siguiente función:\n\nlenght(x): Devuelve el número de elementos de la lista x.\n\n\nEjemplo 3.22 A continuación se muestran varios ejemplos la obtención del tamaño de una lista.\n\nlength(list(1, \"dos\", TRUE))\n\n[1] 3\n\nlength(list(1, c(\"dos\", \"tres\"), list(4, \"cinco\")))\n\n[1] 3\n\nlength(list())\n\n[1] 0\n\n\n\n\n\n3.3.3 Acceso a los elementos de una lista\nSe accede a los elementos de una lista de forma similar a los vectores, mediante índices enteros, lógicos o de cadena, entre corchetes [ ].\n\n3.3.3.1 Acceso mediante un índice entero\nAl igual que los vectores, los elementos de una lista están ordenados y se puede utilizar un índice entero para acceder a los elementos que ocupan una determinada posición.\n\nEjemplo 3.23 A continuación se muestran varios ejemplos de acceso a los elementos de una lista mediante índices enteros.\n\nx <- list(1, \"dos\", TRUE, 4.5)\n# Acceso al elemento que está en la segunda posición\nx[2]\n\n[[1]]\n[1] \"dos\"\n\n# Acceso a los elementos de las posiciones 1 y 3\nx[c(1, 3)]\n\n[[1]]\n[1] 1\n\n[[2]]\n[1] TRUE\n\n# Acceso a todos los elementos excepto el primero y el cuarto\nx[c(-1, -4)]\n\n[[1]]\n[1] \"dos\"\n\n[[2]]\n[1] TRUE\n\n\n\n\n\n3.3.3.2 Acceso mediante un índice lógico\nCuando se utiliza un índice lógico, se obtienen los elementos correspondientes a las posiciones donde está el valor booleano TRUE.\n\nEjemplo 3.24 A continuación se muestran varios ejemplos de acceso a los elementos de una lista mediante índices lógicos.\n\nx <- list(1, \"dos\", TRUE, 4.5)\nx[c(T,F,F,T)]\n\n[[1]]\n[1] 1\n\n[[2]]\n[1] 4.5\n\nx < 2\n\nWarning: NAs introduced by coercion\n\n\n[1]  TRUE    NA  TRUE FALSE\n\n# Filtrado de valores menores que 2\nx[x < 2]\n\nWarning: NAs introduced by coercion\n\n\n[[1]]\n[1] 1\n\n[[2]]\nNULL\n\n[[3]]\n[1] TRUE\n\n\nObsérvese que para los elementos que no tiene sentido la comparación se obtiene NA, y que el acceso mediante este índice devuelve NULL.\n\n\n\n3.3.3.3 Acceso mediante nombres\nSi los elementos de una lista tienen nombre, se puede acceder a ellos utilizando sus nombres como índices. La única diferencia con el acceso mediante cadenas de vectores es que se obtiene siempre una lista, incluso cuando sólo se quiere acceder a un elemento. Para obtener un elemento, y no una lista con ese único elemento, se utilizan dobles corchetes [[ ]].\n\nEjemplo 3.25 A continuación se muestran varios ejemplos de acceso a los elementos de una lista mediante índices de cadena.\n\npersona <- list(\"nombre\" = \"María\", \"edad\" = 21, \"dirección\" = list(\"calle\" = \"Delicias\", \"número\" = 24, \"municipio\" = \"Madrid\"))\npersona[c(\"edad\", \"nombre\")]\n\n$edad\n[1] 21\n\n$nombre\n[1] \"María\"\n\npersona[\"nombre\"]\n\n$nombre\n[1] \"María\"\n\ntypeof(persona[\"nombre\"])\n\n[1] \"list\"\n\n# Acceso a un único elemento\npersona[[\"nombre\"]]\n\n[1] \"María\"\n\n# Acceso a una lista anidada\npersona[[\"dirección\"]][[\"municipio\"]]\n\n[1] \"Madrid\"\n\n\n\nUna alternativa a los dobles corchetes es el operador de acceso a listas $. Este operador además permite utilizar coincidencias parciales en los nombres de los elementos para acceder a ellos.\n\nA continuación se muestran varios ejemplos de acceso a los elementos de una lista mediante el operador $.\n\npersona <- list(\"nombre\" = \"María\", \"edad\" = 21, \"dirección\" = list(\"calle\" = \"Delicias\", \"número\" = 24, \"municipio\" = \"Madrid\"))\n# Acceso a un único elemento\npersona$nombre\n\n[1] \"María\"\n\n# Acceso mediante coincidencia parcial\npersona$nom\n\n[1] \"María\"\n\n# Acceso a una lista anidada\npersona$dirección$municipio\n\n[1] \"Madrid\"\n\n\n\n\n\n\n3.3.4 Modificación de los elementos de una lista\nPara modificar uno o varios elementos de una lista basta con acceder a esos elementos y reasignarles valores con el operador de asignación.\n\nEjemplo 3.26 A continuación se muestran varios ejemplos de modificación de los elementos de una lista.\n\npersona <- list(\"nombre\" = \"María\", \"edad\" = 21)\npersona$edad <- 22\npersona\n\n$nombre\n[1] \"María\"\n\n$edad\n[1] 22\n\n\n\n\n\n3.3.5 Añadir elementos a una lista\nLa forma más sencilla de añadir un elemento con nombre a una lista es indicando el nombre con el operador $ y asignándole un valor con el operador de asignación <-:\n\nx$nombre <- y: Añade el elemento y a la lista x con el nombre nombre.\n\nEl nuevo elemento se añade siempre al final de la lista.\nPara añadir elementos sin nombre o en una posición determinada se puede utilizar la función append():\n\nappend(x, y, pos): Devuelve la lista vector que resulta de añadir a x los elementos de la lista y, a continuación de la posición pos. El parámetro pos es opcional y si no se indica, los elementos de y se añaden al final de los de x.\n\n\nEjemplo 3.27 A continuación se muestran varios ejemplos de añadir nuevos elementos a una lista.\n\npersona <- list(\"nombre\" = \"María\", \"edad\" = 21)\npersona$email <- \"maria@ceu.es\"\npersona\n\n$nombre\n[1] \"María\"\n\n$edad\n[1] 21\n\n$email\n[1] \"maria@ceu.es\"\n\nappend(persona, list(\"sexo\" = \"Mujer\"), 2)\n\n$nombre\n[1] \"María\"\n\n$edad\n[1] 21\n\n$sexo\n[1] \"Mujer\"\n\n$email\n[1] \"maria@ceu.es\"\n\n\n\n\n\n3.3.6 Conversión de una lista en un vector\nEs posible convertir una lista en un vector con la siguiente función:\n\nunlist(x): Devuelve el vector que resulta de aplanar recursivamente la lista x y convertir todos los elementos al mismo tipo mediante coerción de tipos.\n\n\nEjemplo 3.28 A continuación se muestran varios ejemplos de conversión de una lista en un vector.\n\npersona <- list(\"nombre\" = \"María\", \"edad\" = 21, \"dirección\" = list(\"calle\" = \"Delicias\", \"número\" = 24, \"municipio\" = \"Madrid\"))\nunlist(persona)\n\n             nombre                edad     dirección.calle    dirección.número \n            \"María\"                \"21\"          \"Delicias\"                \"24\" \ndirección.municipio \n           \"Madrid\" \n\ntypeof(unlist(persona))\n\n[1] \"character\"\n\n\n\n\n\n\n\n\n\nAdvertencia\n\n\n\nObsérvese que cuando se convierte una lista en un vector, los elementos de la lista se convierten al tipo más general mediante coerción."
  },
  {
    "objectID": "03-tipos-datos-estructurados.html#matrices",
    "href": "03-tipos-datos-estructurados.html#matrices",
    "title": "3  Tipos de datos estructurados",
    "section": "3.4 Matrices",
    "text": "3.4 Matrices\nUna matriz es una estructura de datos bidimensional de elementos del mismo tipo organizados en filas y columnas. Una matriz es similar a un vector pero contiene una atributo adicional con sus dimensiones (número de filas y número de columnas).\n\n3.4.1 Creación de matrices\nPara crear una matriz se utiliza la siguiente función:\n\nmatrix(x, nrow = m, ncol = n): Devuelve la matriz con los elementos del vector x organizados en n filas y m columnas. Habitualmente basta con especificar el número de filas o el número de columnas.\n\n\nEjemplo 3.29 A continuación se muestran varios ejemplos de creación de matrices.\n\nmatrix(1:6, nrow = 2, ncol = 3)\n\n     [,1] [,2] [,3]\n[1,]    1    3    5\n[2,]    2    4    6\n\nmatrix(1:6, nrow = 2)\n\n     [,1] [,2] [,3]\n[1,]    1    3    5\n[2,]    2    4    6\n\nmatrix(1:6, ncol = 3)\n\n     [,1] [,2] [,3]\n[1,]    1    3    5\n[2,]    2    4    6\n\n# La matriz de 1 x 1 \nmatrix()\n\n     [,1]\n[1,]   NA\n\n\n\nComo se puede observar en el ejemplo anterior, los elementos se disponen por columnas, pero se pueden disponer los elementos por filas pasando el parámetro byrow = TRUE a la función matrix.\n\nEjemplo 3.30 A continuación se muestran varios ejemplos de creación de matrices.\n\nmatrix(1:6, nrow = 2)\n\n     [,1] [,2] [,3]\n[1,]    1    3    5\n[2,]    2    4    6\n\nmatrix(1:6, nrow = 2, byrow = TRUE)\n\n     [,1] [,2] [,3]\n[1,]    1    2    3\n[2,]    4    5    6\n\n\n\n\n3.4.1.1 Matrices con nombres de filas y columnas\nEs posible poner nombres a las filas y a las columnas de una matriz añadiendo el parámetro dimnames y pasándole una lista de dos vectores de cadenas con los nombres de las filas y las columnas respectivamente.\n\nEjemplo 3.31 A continuación se muestran varios ejemplos de creación de matrices con nombres de filas y columnas.\n\nmatrix(1:6, nrow = 2, ncol = 3, dimnames = list(c(\"fila1\", \"fila2\"), c(\"columna1\", \"columna2\", \"columna3\")))\n\n      columna1 columna2 columna3\nfila1        1        3        5\nfila2        2        4        6\n\n\n\nPara obtener los nombres de las filas y las columnas de una matriz se utilizan las siguientes funciones:\n\nrownames(x): Devuelve un vector de cadenas de caracteres con los nombres de las filas de la matriz x.\ncolnames(x): Devuelve un vector de cadenas de caracteres con los nombres de las columnas de la matriz x.\n\n\nEjemplo 3.32 A continuación se muestran varios ejemplos de obtención de los nombres de las filas y columnas de una matriz con nombres.\n\nx <- matrix(1:6, nrow = 2, ncol = 3, dimnames = list(c(\"fila1\", \"fila2\"), c(\"columna1\", \"columna2\", \"columna3\")))\nrownames(x)\n\n[1] \"fila1\" \"fila2\"\n\ncolnames(x)\n\n[1] \"columna1\" \"columna2\" \"columna3\"\n\n\n\n\n\n\n3.4.2 Tamaño y dimensiones de una matriz\nPara obtener el número de elementos y las dimensiones de una matriz se pueden utilizar las siguientes funciones:\n\nlength(x): Devuelve un entero con el número de elementos de la matriz x.\nnrow(x): Devuelve un entero con el número de filas de la matriz x.\nncol(x): Devuelve un entero con el número de columnas de la matriz x.\ndim(x): Devuelve un vector de dos enteros con el número de filas y el número de columnas de la matriz x.\n\n\nEjemplo 3.33 A continuación se muestran varios ejemplos de acceso a las dimensiones de una matriz.\n\nx <- matrix(1:6, nrow = 2)\nlength(x)\n\n[1] 6\n\nnrow(x)\n\n[1] 2\n\nncol(x)\n\n[1] 3\n\ndim(x)\n\n[1] 2 3\n\n\n\nUsando esta última función se pueden modificar las dimensiones de una matriz asignando un vector de dos enteros con las nuevas dimensiones. Esto también permite crear una matriz a partir de un vector.\n\nEjemplo 3.34 A continuación se muestran varios ejemplos de modificación de las dimensiones de una matriz.\n\nx <- 1:6\ndim(x) <- c(2, 3)\nx\n\n     [,1] [,2] [,3]\n[1,]    1    3    5\n[2,]    2    4    6\n\ndim(x) <- c(3, 2)\nx\n\n     [,1] [,2]\n[1,]    1    4\n[2,]    2    5\n[3,]    3    6\n\n\n\n\n\n3.4.3 Acceso a los elementos de una matriz\nPara acceder a los elementos de una matriz se utilizan dos índices (uno para las filas y otro para las columnas), separados por comas y entre corchetes [] a continuación de la matriz. Al igual que para los vectores, los índices pueden ser enteros, lógicos o de cadenas de caracteres.\n\n3.4.3.1 Acceso mediante índices enteros\nPara acceder a los elementos de una matriz mediante índices enteros se indica el número de fila y el número de columna del elemento entre corchetes:\n\nx[i,j]: Devuelve el elemento de la matriz x que está en la fila i y la columna j.\n\nSe puede acceder a más de un elemento indicando un vector de enteros para las filas y otro para las columnas. De esta manera se obtiene una submatriz. Si no se indica la fila o la columna se obtienen todos los elementos de todas las filas o columnas. Al igual que para vectores, se pueden utilizar enteros negativos para descartar filas o columnas\n\nEjemplo 3.35 A continuación se muestran varios ejemplos de acceso a los elementos de una matriz.\n\nx <- matrix(1:9, nrow = 3)\nx\n\n     [,1] [,2] [,3]\n[1,]    1    4    7\n[2,]    2    5    8\n[3,]    3    6    9\n\n# Acceso al elemento de la segunda fila y tercera columna\nx[2,3]\n\n[1] 8\n\n# Acceso a la submatriz de la primera y tercera filas, y tercera y segunda columnas\nx[c(1, 3), c(3, 2)]\n\n     [,1] [,2]\n[1,]    7    4\n[2,]    9    6\n\n# Acceso a la primera fila\nx[1, ]\n\n[1] 1 4 7\n\n# Acceso a la segunda columna\nx[, 2]\n\n[1] 4 5 6\n\n# Acceso a la submatriz con todos los elementos salvo la tercera fila y la segunda columna\nx[-3, -2]\n\n     [,1] [,2]\n[1,]    1    7\n[2,]    2    8\n\n\n\n\n\n3.4.3.2 Acceso mediante índices lógicos\nCuando se utilizan índices lógicos, se obtienen los elementos correspondientes a las filas y columnas donde está el valor booleano TRUE.\n\nEjemplo 3.36 A continuación se muestran varios ejemplos de acceso a los elementos de una matriz.\n\nx <- matrix(1:9, nrow = 3)\nx\n\n     [,1] [,2] [,3]\n[1,]    1    4    7\n[2,]    2    5    8\n[3,]    3    6    9\n\n# Acceso al elemento de la segunda fila y tercera columna\nx[c(F, T, F), c(F, F, T)]\n\n[1] 8\n\n# Acceso a la submatriz de la primera y tercera filas, y segunda y tercera columnas\nx[c(T, F, T), c(F, T, T)]\n\n     [,1] [,2]\n[1,]    4    7\n[2,]    6    9\n\n# Acceso a la primera fila\nx[c(T, F, F), ]\n\n[1] 1 4 7\n\n# Acceso a la segunda columna\nx[, c(F, T, F)]\n\n[1] 4 5 6\n\n\n\n\n\n3.4.3.3 Acceso mediante índices de cadena\nSi las filas y las columnas de una matriz tienen nombre, es posible acceder a sus elementos usando los nombres de las filas y columnas como índices.\n\nEjemplo 3.37 A continuación se muestran varios ejemplos de acceso a los elementos de una matriz mediante los nombres de sus filas y columnas.\n\nx <- matrix(1:9, nrow = 3, dimnames = list(c(\"f1\", \"f2\", \"f3\"), c(\"c1\", \"c2\", \"c3\")))\nx\n\n   c1 c2 c3\nf1  1  4  7\nf2  2  5  8\nf3  3  6  9\n\n# Acceso al elemento de la segunda fila y tercera columna\nx[\"f2\", \"c3\"]\n\n[1] 8\n\n# Acceso a la submatriz de la primera y tercera filas, y tercera y segunda columnas\nx[c(\"f1\", \"f3\"), c(\"c3\", \"c2\")]\n\n   c3 c2\nf1  7  4\nf3  9  6\n\n\n\nFinalmente, es posible combinar distintos tipos de índices (enteros, lógicos o de cadena) para indicar las filas y las columnas a las que acceder.\n\n\n\n3.4.4 Pertenencia a una matriz\nPara comprobar si un valor en particular es un elemento de una matriz se puede utilizar el operador %in%:\n\nx %in% y: Devuelve el booleano TRUE si x es un elemento de la matriz y, y FALSE en caso contrario.\n\n\nEjemplo 3.38 A continuación se muestran varios ejemplos de pertenencia de elementos a una matriz.\n\nx <- matrix(1:9, nrow = 3)\n2 %in% x\n\n[1] TRUE\n\n-1 %in% x\n\n[1] FALSE\n\n\n\n\n\n3.4.5 Modificación de los elementos de una matriz\nPara modificar uno o varios elementos de una matriz basta con acceder a esos elementos y usar el operador de asignación para asignar nuevos valores.\n\nEjemplo 3.39 A continuación se muestran varios ejemplos de modificación de los elementos de un vector.\n\nx <- matrix(1:9, nrow = 3)\nx\n\n     [,1] [,2] [,3]\n[1,]    1    4    7\n[2,]    2    5    8\n[3,]    3    6    9\n\nx[2,3] <- 0\nx\n\n     [,1] [,2] [,3]\n[1,]    1    4    7\n[2,]    2    5    0\n[3,]    3    6    9\n\nx[c(1, 3), 1:2] <- -1\nx\n\n     [,1] [,2] [,3]\n[1,]   -1   -1    7\n[2,]    2    5    0\n[3,]   -1   -1    9\n\n\n\n\n\n3.4.6 Añadir elementos a una matriz\nPara añadir nuevas filas o columnas a una matriz se utilizan las siguientes funciones:\n\nrbind(x, y): Devuelve la matriz que resulta de añadir nuevas filas a la matriz x con los elementos del vector y.\ncbind(x, y): Devuelve la matriz que resulta de añadir nuevas columnas a la matriz x con los elementos del vector y.\n\n\nEjemplo 3.40 A continuación se muestran varios ejemplos de añadir nuevas filas y columnas a una matriz.\n\nx <- matrix(1:6, nrow = 2)\nx\n\n     [,1] [,2] [,3]\n[1,]    1    3    5\n[2,]    2    4    6\n\n# Añadir una nueva fila\nrbind(x, c(7, 8, 9))\n\n     [,1] [,2] [,3]\n[1,]    1    3    5\n[2,]    2    4    6\n[3,]    7    8    9\n\n# Añadir una nueva columna\ncbind(x, c(7, 8))\n\n     [,1] [,2] [,3] [,4]\n[1,]    1    3    5    7\n[2,]    2    4    6    8\n\n\n\n\n\n\n\n\n\nAdvertencia\n\n\n\nObsérvese que si el número de elementos proporcionados en el vector es menor del necesario para completar la fila o columna, se reutilizan los elementos del vector empezando desde el principio.\n\n\n\n\n3.4.7 Trasponer una matriz\nPara trasponer una matriz se utiliza la función siguiente:\n\nt(x): Devuelve la matriz traspuesta de la matriz x.\n\n\nEjemplo 3.41 A continuación se muestran un ejemplo de la trasposición de una matriz.\n\nx <- matrix(1:6, nrow=2)\nt(x)\n\n     [,1] [,2]\n[1,]    1    2\n[2,]    3    4\n[3,]    5    6\n\n\n\n\n\n3.4.8 Operaciones aritméticas con matrices\n\n3.4.8.1 Operaciones aritméticas elemento a elemento\nPara matrices numéricas las operaciones aritméticas habituales se aplican elemento a elemento. Si las dimensiones de las matrices son distintas se produce un error.\n\nEjemplo 3.42 A continuación se muestran varios ejemplos de operaciones aritméticas elemento a elemento con matrices numéricas.\n\nx <- matrix(1:6, nrow = 2)\nx\n\n     [,1] [,2] [,3]\n[1,]    1    3    5\n[2,]    2    4    6\n\ny <- matrix(c(0, 1, 0, -1, 0, 1), nrow = 2)\ny\n\n     [,1] [,2] [,3]\n[1,]    0    0    0\n[2,]    1   -1    1\n\nx + y\n\n     [,1] [,2] [,3]\n[1,]    1    3    5\n[2,]    3    3    7\n\nx * y\n\n     [,1] [,2] [,3]\n[1,]    0    0    0\n[2,]    2   -4    6\n\nx / y\n\n     [,1] [,2] [,3]\n[1,]  Inf  Inf  Inf\n[2,]    2   -4    6\n\nx ^ y\n\n     [,1] [,2] [,3]\n[1,]    1 1.00    1\n[2,]    2 0.25    6\n\n\n\n\n\n\n\n\n\nAdvertencia\n\n\n\nObsérvese en el ejemplo anterior que la división por 0 produce el valor Inf que representa infinito.\n\n\n\n\n3.4.8.2 Multiplicación de matrices\nPara multiplicar dos matrices numéricas se utiliza el operador %*%.\n\nEjemplo 3.43 A continuación se muestran varios ejemplos del producto de dos matrices numéricas.\n\nx <- matrix(1:6, ncol = 3)\ny <- matrix(1:6, nrow = 3)\nx %*% y\n\n     [,1] [,2]\n[1,]   22   49\n[2,]   28   64\n\ny %*% x\n\n     [,1] [,2] [,3]\n[1,]    9   19   29\n[2,]   12   26   40\n[3,]   15   33   51\n\n\n\n\n\n\n\n\n\nAdvertencia\n\n\n\nPara poder multiplicar dos matrices deben tener dimensiones compatibles. Si el número de columnas de la primera matriz no es igual que el número de filas de la segunda se produce un error.\n\n\n\n\n\n3.4.9 Determinante de una matriz\nPara calcular el determinante de una matriz numérica cuadrada se utiliza la siguiente función:\n\ndet(x): Devuelve el determinante de la matriz x. Si x no es una matriz numérica cuadrada produce un error.\n\n\nEjemplo 3.44 A continuación se muestra un ejemplo del cálculo del determinante de una matriz numérica cuadrada.\n\nx <- matrix(1:4, ncol = 2)\ndet(x)\n\n[1] -2\n\n\n\n\n\n3.4.10 Inversa de una matriz\nPara calcular la matriz inversa de una matriz numérica cuadrada se utiliza la siguiente función:\n\nsolve(x): Devuelve la matriz inversa de la matriz x. Si x no es una matriz numérica cuadrada produce un error. Si la matriz no es invertible por tener determinante nulo también se obtiene un error.\n\n\nEjemplo 3.45 A continuación se muestra un ejemplo del cálculo del determinante de una matriz numérica cuadrada.\n\nx <- matrix(1:4, nrow = 2)\nsolve(x)\n\n     [,1] [,2]\n[1,]   -2  1.5\n[2,]    1 -0.5\n\n# El producto de una matriz por su inversa es la matriz identidad.\nx %*% solve(x)\n\n     [,1] [,2]\n[1,]    1    0\n[2,]    0    1\n\n\n\n\n\n3.4.11 Autovalores y autovectores de una matriz\nPara calcular los autovalores y los autovectores de una matriz numérica cuadrada se utiliza la siguiente función:\n\neigen(x): Devuelve una lista con los autovalores y los autovectores de la matriz x. Para acceder a los autovalores se utiliza el nombre values y para acceder a los autovectores se utiliza el nombre vectors.\n\n\nEjemplo 3.46 A continuación se muestra un ejemplo del cálculo los autovalores y los autovectores de una matriz numérica cuadrada. Si x no es una matriz numérica cuadrada produce un error.\n\nx <- matrix(1:4, nrow = 2)\nx\n\n     [,1] [,2]\n[1,]    1    3\n[2,]    2    4\n\n# Autovalores\neigen(x)$values\n\n[1]  5.3722813 -0.3722813\n\n# Autovectores\neigen(x)$vectors\n\n           [,1]       [,2]\n[1,] -0.5657675 -0.9093767\n[2,] -0.8245648  0.4159736"
  },
  {
    "objectID": "03-tipos-datos-estructurados.html#data-frames",
    "href": "03-tipos-datos-estructurados.html#data-frames",
    "title": "3  Tipos de datos estructurados",
    "section": "3.5 Data frames",
    "text": "3.5 Data frames\nUn data frame es una estructura bidimensional cuyos elementos se organizan por filas y columnas de manera similar a una matriz. La principal diferencia con las matrices es que sus columnas están formadas por vectores, pero pueden tener tipos de datos distintos. Un data frame es un caso particular de lista formada por vectores del mismo tamaño con nombre.\nLos data frames son las estructuras de datos más utilizadas en R para almacenar los datos en los análisis estadísticos.\n\n3.5.1 Creación de un data frame\nPara crear un data frame se utiliza la siguiente función:\n\ndata.frame(nombrex = x, nombrey = y, ...): Devuelve el data frame con columnas los vectores x, y, etc. y nombres de columna nombrex, nombrey, etc.\n\n\nEjemplo 3.47 A continuación se muestran varios ejemplos de la creación de data frames.\n\ndf <- data.frame(asignatura = c(\"Matemáticas\", \"Física\", \"Economía\"), nota = c(8.5, 7, 4.5))\ndf\n\n   asignatura nota\n1 Matemáticas  8.5\n2      Física  7.0\n3    Economía  4.5\n\nstr(df)\n\n'data.frame':   3 obs. of  2 variables:\n $ asignatura: chr  \"Matemáticas\" \"Física\" \"Economía\"\n $ nota      : num  8.5 7 4.5\n\n# Data frame vacío\ndata.frame()\n\ndata frame with 0 columns and 0 rows\n\n\n\nPara grandes conjuntos de datos es más común crear un data frame a partir de un fichero en formato csv mediante la siguiente función:\n\nread.csv(f): Devuelve el data frame que se genera a partir de los datos del fichero csv f. Cada fila del fichero csv se corresponde con una fila del data frame y por defecto utiliza la coma , parara separar los datos de las columnas y punto . como separador de decimales de los datos numéricos. Los nombres de las columnas se obtienen automáticamente a partir de la primera fila del fichero.\nread.csv2(f): Funciona igual que la función anterior pero utiliza como separador de columnas el punto y coma ; y como separador de decimales la coma ,.\n\n\nEjemplo 3.48 A continuación se muestra un ejemplo de creación de un data frame a partir de un fichero csv.\n\ndf <- read.csv('https://raw.githubusercontent.com/asalber/manual-r/master/datos/colesterol.csv')\ndf\n\n                            nombre edad sexo peso altura colesterol\n1     José Luis Martínez Izquierdo   18    H   85   1.79        182\n2                   Rosa Díaz Díaz   32    M   65   1.73        232\n3            Javier García Sánchez   24    H   NA   1.81        191\n4              Carmen López Pinzón   35    M   65   1.70        200\n5             Marisa López Collado   46    M   51   1.58        148\n6                Antonio Ruiz Cruz   68    H   66   1.74        249\n7          Antonio Fernández Ocaña   51    H   62   1.72        276\n8            Pilar Martín González   22    M   60   1.66         NA\n9             Pedro Gálvez Tenorio   35    H   90   1.94        241\n10         Santiago Reillo Manzano   46    H   75   1.85        280\n11           Macarena Álvarez Luna   53    M   55   1.62        262\n12      José María de la Guía Sanz   58    H   78   1.87        198\n13 Miguel Angel Cuadrado Gutiérrez   27    H  109   1.98        210\n14           Carolina Rubio Moreno   20    M   61   1.77        194\n\n\n\n\n\n3.5.2 Coerción de otras estructuras de datos a data frames\nPara convertir otras estructuras de datos en data frames, se utiliza la siguiente función:\n\nas.data.frame(x): Devuelve el data frame que se obtiene a partir la estructura de datos x a plicanco las siguientes reglas de coerción:\n\nSi x es un vector se obtiene un data frame con una sola columna.\nSi x es una lista se obtiene un data frame con tantas columnas como elementos tenga la lista. Si los elementos de la lista tienen tamaños distintos se obtiene un error.\nSi x es una matriz se obtiene un data frame con el mismo número de columnas y filas que la matriz.\n\n\n\n\n3.5.3 Acceso a los elementos de un data frame\nPuesto que un data frame es una lista, se puede acceder a sus elementos como se accede a los elementos de una lista utilizando índices. Con corchetes simples [ ] se obtiene siempre un data frame, mientras que con corchetes dobles [[ ]] o $ se obtiene un vector. Pero también se puede acceder a los elementos de un data frame como si fuese una matriz, indicando un par de índices para las filas y las columnas respectivamente.\n\nEjemplo 3.49 A continuación se muestran varios ejemplos de acceso a los elementos de un data frame.\n\ndf <- data.frame(asignatura = c(\"Matemáticas\", \"Física\", \"Economía\"), nota = c(8.5, 7, 4.5))\ndf\n\n   asignatura nota\n1 Matemáticas  8.5\n2      Física  7.0\n3    Economía  4.5\n\n# Acceso como lista\ndf[\"asignatura\"]\n\n   asignatura\n1 Matemáticas\n2      Física\n3    Economía\n\ndf$asignatura\n\n[1] \"Matemáticas\" \"Física\"      \"Economía\"   \n\n# Acceso como matriz\ndf[2:3, \"nota\"]\n\n[1] 7.0 4.5\n\ndf[df$nota >= 5, ]\n\n   asignatura nota\n1 Matemáticas  8.5\n2      Física  7.0\n\n\n\nObsérvese en el último ejemplo anterior cómo se pueden utilizar condiciones lógicas para filtrar un data frame.\nPara acceder a las primeras o últimas filas de un data frame se pueden utilizar las siguientes funciones:\n\nhead(df, n): Devuelve un data frame con las n primeras filas del data frame df.\ntail(df, n): Devuelve un data frame con las n últimas filas del data frame df.\n\nEstas funciones son útiles para darse una idea del contenido de un data frame con muchas filas.\n\nEjemplo 3.50 A continuación se muestran varios ejemplos de acceso a las primeras o últimas filas de un data frame.\n\ndf <- data.frame(x = 1:26, y = letters) # letters es un vector predefinido con las letras del abecedario.\nhead(df, 3)\n\n  x y\n1 1 a\n2 2 b\n3 3 c\n\ntail(df, 2)\n\n    x y\n25 25 y\n26 26 z\n\n\n\n\n\n3.5.4 Modificación de los elementos de un data frame\nPara modificar uno o varios elementos de un data frame basta con acceder a esos elementos y usar el operador de asignación para asignar nuevos valores.\n\nEjemplo 3.51 A continuación se muestran varios ejemplos de modificación de los elementos de un vector.\n\ndf <- data.frame(asignatura = c(\"Matemáticas\", \"Física\", \"Economía\"), nota = c(8.5, 7, 4.5))\ndf\n\n   asignatura nota\n1 Matemáticas  8.5\n2      Física  7.0\n3    Economía  4.5\n\ndf[3, \"nota\"] <- 5\ndf\n\n   asignatura nota\n1 Matemáticas  8.5\n2      Física  7.0\n3    Economía  5.0\n\n\n\n\n\n3.5.5 Añadir elementos a un data frame\nPara añadir nuevas filas o columnas a una data frame se utilizan las mismas funciones que para matrices:\n\nrbind(df, x): Devuelve el data frame que resulta de añadir nuevas filas al data frame df con los elementos de la lista x.\ncbind(df, nombrex = x): Devuelve el data frame que resulta de añadir nuevas columnas al data frame df con los elementos del vector x con nombre nombrex.\n\n\nEjemplo 3.52 A continuación se muestran varios ejemplos de añadir nuevas filas y columnas a un data frame.\n\ndf <- data.frame(asignatura = c(\"Matemáticas\", \"Física\", \"Economía\"), nota = c(8.5, 7, 4.5))\ndf\n\n   asignatura nota\n1 Matemáticas  8.5\n2      Física  7.0\n3    Economía  4.5\n\n# Añadir una nueva fila\nrbind(df, list(\"Programación\" , 10))\n\n    asignatura nota\n1  Matemáticas  8.5\n2       Física  7.0\n3     Economía  4.5\n4 Programación 10.0\n\n# Añadir una nueva columna\ncbind(df, créditos = c(6, 4, 3))\n\n   asignatura nota créditos\n1 Matemáticas  8.5        6\n2      Física  7.0        4\n3    Economía  4.5        3\n\n\n\n\n\n3.5.6 Eliminar filas y columnas de un data frame\nPara eliminar una columna de un data frame basta con acceder a la columna y asignarle el valor NULL, mientras que para eliminar una fila basta con acceder a la fila con índice negativo.\n\nEjemplo 3.53 A continuación se muestran varios ejemplos de eliminación de filas y columnas de un data frame.\n\ndf <- data.frame(asignatura = c(\"Matemáticas\", \"Física\", \"Economía\"), nota = c(8.5, 7, 4.5), créditos = c(6, 4, 3))\ndf\n\n   asignatura nota créditos\n1 Matemáticas  8.5        6\n2      Física  7.0        4\n3    Economía  4.5        3\n\n# Eliminar una columna\ndf$nota <- NULL\ndf\n\n   asignatura créditos\n1 Matemáticas        6\n2      Física        4\n3    Economía        3\n\n# Eliminar una fila\ndf[-2, ]\n\n   asignatura créditos\n1 Matemáticas        6\n3    Economía        3"
  },
  {
    "objectID": "03-tipos-datos-estructurados.html#ejercicios",
    "href": "03-tipos-datos-estructurados.html#ejercicios",
    "title": "3  Tipos de datos estructurados",
    "section": "3.6 Ejercicios",
    "text": "3.6 Ejercicios\n\nEjercicio 3.1 La siguiente tabla recoge las notas de los alumnos de un curso con dos asignaturas.\n\n\n\nAlumno\nSexo\nFísica\nQuímica\n\n\n\n\nCarlos\nH\n6.7\n8.1\n\n\nMaría\nM\n7.2\n9.5\n\n\nCarmen\nM\n5.5\n5\n\n\nPedro\nH\n\n4.5\n\n\nLuis\nH\n3.5\n5\n\n\nSara\nM\n6.2\n4\n\n\n\n\nDefinir cuatro vectores con el nombre, el sexo y las notas de Física y Química.\n\n\n\n\n\n\n\nSolución\n\n\n\n\n\n\nnombre <- c(\"Carlos\", \"María\", \"Carmen\", \"Pedro\", \"Luis\", \"Sara\")\nsexo <- c(\"H\", \"M\", \"M\", \"H\", \"H\", \"M\")\nfisica <- c(6.7, 7.2, 5.5, NA, 3.5, 6.2)\nquimica <- c(8.1, 9.5, 5, 4.5, 5, 4)\n\n\n\n\n\nConvertir el sexo en un factor y mostrar sus niveles.\n\n\n\n\n\n\n\nSolución\n\n\n\n\n\n\nsexo <- factor(sexo)\nlevels(sexo)\n\n[1] \"H\" \"M\"\n\n\n\n\n\n\nCrear un nuevo vector con la nota media de Física y Química.\n\n\n\n\n\n\n\nSolución\n\n\n\n\n\n\nmedia <- (fisica + quimica) / 2\nmedia\n\n[1] 7.40 8.35 5.25   NA 4.25 5.10\n\n\n\n\n\n\nCrear la variable booleana aprobado que tenga el valor TRUE si la media es mayor o igual que 5 y FALSE en caso contrario.\n\n\n\n\n\n\n\nSolución\n\n\n\n\n\n\naprobado <- media >= 5\naprobado\n\n[1]  TRUE  TRUE  TRUE    NA FALSE  TRUE\n\n\n\n\n\n\nAplicar un filtro al vector de nombres para quedarse con los nombres de los alumnos que han aprobado.\n\n\n\n\n\n\n\nSolución\n\n\n\n\n\n\nnombre[aprobado & !is.na(aprobado)]\n\n[1] \"Carlos\" \"María\"  \"Carmen\" \"Sara\"  \n\n\n\n\n\n\nCrear un data frame con el nombre, sexo y las notas de Física y Química.\n\n\n\n\n\n\n\nSolución\n\n\n\n\n\n\ndf <- data.frame(nombre, sexo, fisica, quimica)\ndf\n\n  nombre sexo fisica quimica\n1 Carlos    H    6.7     8.1\n2  María    M    7.2     9.5\n3 Carmen    M    5.5     5.0\n4  Pedro    H     NA     4.5\n5   Luis    H    3.5     5.0\n6   Sara    M    6.2     4.0\n\n\n\n\n\n\nAñadir el vector con la media al data frame.\n\n\n\n\n\n\n\nSolución\n\n\n\n\n\n\ndf$media <- media\ndf\n\n  nombre sexo fisica quimica media\n1 Carlos    H    6.7     8.1  7.40\n2  María    M    7.2     9.5  8.35\n3 Carmen    M    5.5     5.0  5.25\n4  Pedro    H     NA     4.5    NA\n5   Luis    H    3.5     5.0  4.25\n6   Sara    M    6.2     4.0  5.10\n\n\n\n\n\n\nFiltrar el data frame para quedarse con el nombre y la media de las mujeres que han aprobado.\n\n\n\n\n\n\n\nSolución\n\n\n\n\n\n\ndf[sexo == \"M\" & media >= 5, c(\"nombre\", \"media\")]\n\n  nombre media\n2  María  8.35\n3 Carmen  5.25\n6   Sara  5.10"
  },
  {
    "objectID": "04-estructuras-control.html#estructuras-condicionales",
    "href": "04-estructuras-control.html#estructuras-condicionales",
    "title": "4  Estructuras de control",
    "section": "4.1 Estructuras condicionales",
    "text": "4.1 Estructuras condicionales\nLas estructuras condicionales permiten evaluar el estado del programa y tomar decisiones sobre qué código ejecutar en función del mismo.\n\n4.1.1 Condicionales (if)\nLa principal estructura condicional comienza con la palabra reservada if, lleva asociada expresión de tipo lógico o booleano y permite ejecutar un bloque de código dependiendo de si la evaluación de esa expresión es TRUE o FALSE.\n\nif (<exp>) {\n  <código>\n}\n\nSi el resultado de evaluar la expresión <exp> es TRUE entonces se ejecuta el código <código>, mientras que si es FALSE no.\n\n\n\nDiagrama de flujo de la estructura condicional simple\n\n\n\n\n\n\n\nDiagrama de flujo de la estructura condicional simple\n\n\n\n\n\nEjemplo 4.1 A continuación se muestra un ejemplo de estructura condicional con if.\n\nx <- 1\ny <- 0\nif (y != 0){\n  print(x / y)\n}\n\n\nSi se desea ejecutar un bloque de código alternativo cuando no se cumpla la condición se puede añadir a continuación con la palabra reservada else.\n\nif (<exp>) {\n  <código 1>\n} else {\n  <código 2>\n}\n\nEn este caso, si la evaluación de la condición es TRUE se ejecuta el código <código 1> y si es FALSE se ejecuta el código <código 2>.\n\n\n\nDiagrama de flujo de la estructura condicional doble\n\n\n\nEjemplo 4.2 A continuación se muestra un ejemplo de estructura condicional con if y else.\n\nnota <- 8.5\nif (nota < 5){\n  print(\"Suspenso\")\n} else {\n  print(\"Aprobado\")\n}\n\n[1] \"Aprobado\"\n\n\n\nSe puede comprobar más de una condición encadenando otra instrucción if tras las instrucción else.\n\nif (<exp 1>) {\n  <código 1>\n} else if (<exp 2>) {\n  <código 2>) {\n…\n} else {\n  <código n>\n}\n\nCuando se encadenan múltiples condiciones de esta forma, solamente se ejecuta el bloque de código asociado a la primera condición cuya evaluación sea TRUE. El último bloque de código solamente se ejecuta si todas las condiciones son falsas.\n\n\n\nDiagrama de flujo de la estructura condicional múltiple\n\n\n\nEjemplo 4.3 A continuación se muestra un ejemplo de estructura condicional múltiple.\n\nnota <- 8.5\nif (nota < 5){\n  print(\"Suspenso\")\n} else if (nota < 7) {\n  print(\"Aprobado\")\n} else if (nota < 9) {\n  print(\"Notable\")\n} else {\n  print(\"Sobresaliente\")\n}\n\n[1] \"Notable\"\n\n\n\n\n\n4.1.2 La función switch()\nOtra forma de tomar decisiones sobre el código a ejecutar es la función switch.\n\nswitch(x, l): Ejecuta el código del valor de la lista l cuyo nombre asociado coincide con el resultado de evaluar la expresión x. Si el resultado de evaluar x no es ningún nombre de los elementos de la lista devuelve NULL.\n\n\nEjemplo 4.4 A continuación se muestra un ejemplo de uso de la función switch.\n\ntipo.iva <- \"reducido\"\nprecio <- 1000\niva <- precio * switch(tipo.iva, \"superreducido\" = 4, \"reducido\" = 10, \"normal\" = 21) / 100\niva\n\n[1] 100"
  },
  {
    "objectID": "04-estructuras-control.html#bucles",
    "href": "04-estructuras-control.html#bucles",
    "title": "4  Estructuras de control",
    "section": "4.2 Bucles",
    "text": "4.2 Bucles\nUn bucle es una estructura que permite la repetición de un bloque de código. En R existen dos tipos de bucles, los bucles iterativos y los bucles condicionales.\n\n4.2.1 Bucles iterativos (for)\nLo bucles iterativos repiten un bloque de código un número determinado de veces. Comienzan por la palabra reservada for y llevan asociado un iterador, que es una variable que recorre una secuencia de un tipo de datos compuesto, normalmente un vector o una lista. El bloque de código se ejecuta tantas veces como elementos tenga la secuencia, y en cada repetición el iterador toma como valor un elemento distinto de la secuencia.\n\nfor (iin<secuencia>) {\n  <código>\n}\n\n\n\n\nDiagrama de flujo de un bucle iterativo\n\n\n\nEjemplo 4.5 A continuación se muestra varios ejemplos de uso del bucle for.\n\nasignaturas <- c(\"Matemáticas\", \"Física\", \"Programación\")\nfor (i in asignaturas) {\n  print(i)\n}\n\n[1] \"Matemáticas\"\n[1] \"Física\"\n[1] \"Programación\"\n\nfor (i in 1:5) {\n  print(paste(\"El cuadrado de \", i, \" es \", i^2))\n}\n\n[1] \"El cuadrado de  1  es  1\"\n[1] \"El cuadrado de  2  es  4\"\n[1] \"El cuadrado de  3  es  9\"\n[1] \"El cuadrado de  4  es  16\"\n[1] \"El cuadrado de  5  es  25\"\n\n\n\nTambién es posible recorrer los elementos de la secuencia por posición ayudándonos de la siguiente función:\n\nseq_along(x): que devuelve un vector con los enteros desde 1 hasta el número de elementos de la secuencia x.\n\n\nEjemplo 4.6 A continuación se muestra un ejemplo de bucle for que recorre los elementos de un vector por posición.\n\nasignaturas <- c(\"Matemáticas\", \"Física\", \"Programación\")\nfor (i in seq_along(asignaturas)){\n  print(paste(\"Asignatura \", i, \":\", asignaturas[i]))\n}\n\n[1] \"Asignatura  1 : Matemáticas\"\n[1] \"Asignatura  2 : Física\"\n[1] \"Asignatura  3 : Programación\"\n\n\n\nLos bucles iterativos se utilizan habitualmente para recorrer estructuras de una dimensión como los vectores y las listas, donde se sabe de antemano el número de elementos que contiene y, por tanto, el número de iteraciones del bucle. No obstante, también se pueden recorrer estructuras de más de una dimensión, como por ejemplo matrices, utilizando varios bucles for anidados.\n\nEjemplo 4.7 A continuación se muestra varios ejemplos de dos bucles for anidados para recorrer los elementos de una matriz.\n\nx <- matrix(1:6, 2, 3)\nfor (i in 1:nrow(x)) {\n  for (j in 1:ncol(x)){\n    print(x[i,j])\n  }\n}\n\n[1] 1\n[1] 3\n[1] 5\n[1] 2\n[1] 4\n[1] 6\n\n\n\n\n\n4.2.2 Bucles condicionales (while)\nLos bucles condicionales repiten un bloque de código mientras se cumpla una condición. Comienzan con la palabra reservada while y llevan asociada una expresión lógica, de manera que mientras la evaluación de la expresión lógica sea TRUE se repite la ejecución del bloque de código que contiene.\n\nwhile (<condición>) {\n  <código>\n}\n\nLa expresión lógica <condición> se evalúa antes de ejecutar el bloque de código y solo se ejecuta el <código> si el resultado de la evaluación es TRUE. Obsérvese que cuando el flujo de ejecución del programa llega al bucle while si la condición no es cierta, el código no se ejecuta ni tan siquiera una vez.\n\n\n\nDiagrama de flujo de un bucle condicional\n\n\n\nEjemplo 4.8 A continuación se muestra un ejemplo de bucle while.\n\ni <- 5\nwhile (i >= 0) {\n  print(i)\n  i <- i - 1\n}\n\n[1] 5\n[1] 4\n[1] 3\n[1] 2\n[1] 1\n[1] 0\n\n\n\n\n\n4.2.3 La instrucción break\nLa instrucción break se utiliza para detener un bucle y salir de él, tanto en bucles iterativos como en bucles condicionales. Normalmente se suele utilizar esta instrucción cuando se cumple una determinada condición en bloque de código del bucle y se decide parar su ejecución y salir del bucle.\n\nEjemplo 4.9 A continuación se muestra un ejemplo de uso de la instrucción break.\n\n# Bucle que recorre los números enteros del -2 al 2 pero termina al llegar al 0.\nfor (i in -2:2) {\n  if (i == 0) {\n    break\n  } \n  print(i)\n}\n\n[1] -2\n[1] -1\n\n\n\n\n\n4.2.4 La instrucción next\nLa instrucción next se utiliza para interrumpir la ejecución del bloque de código de un bucle, pero en lugar de salir del bucle pasa a la siguiente iteración. Si se trata de un bucle iterativo el iterador pasa al siguiente elemento de la secuencia de iteración y si se trata de un bucle condicional se pasa evaluar de nuevo la condición de repetición.\n:::{#exm-continuacion-bucle-next} A continuación se muestra un ejemplo de uso de la instrucción next.\n\n# Bucle que recorre los enteros del 1 al 10 pero solo imprime los números pares.\nfor (i in 1:10) {\n  if (i %% 2) {\n    next\n  }\n  print(i)\n}\n\n[1] 2\n[1] 4\n[1] 6\n[1] 8\n[1] 10"
  },
  {
    "objectID": "04-estructuras-control.html#ejercicios",
    "href": "04-estructuras-control.html#ejercicios",
    "title": "4  Estructuras de control",
    "section": "4.3 Ejercicios",
    "text": "4.3 Ejercicios\n\nEjercicio 4.1 Considérese el data frame creado en el Ejercicio 3.1.\n\nnombre <- c(\"Carlos\", \"María\", \"Carmen\", \"Pedro\", \"Luis\", \"Sara\")\nsexo <- c(\"H\", \"M\", \"M\", \"H\", \"H\", \"M\")\nfisica <- c(6.7, 7.2, 5.5, NA, 3.5, 6.2)\nquimica <- c(8.1, 9.5, 5, 4.5, 5, 4)\ndf <- data.frame(nombre, sexo, fisica, quimica)\n\n\nUsando la función mean(), calcular la media de Física y de Química usando un bucle iterativo.\n\n\n\n\n\n\n\nSolución\n\n\n\n\n\n\nmedias <- NULL\nfor (i in 3:4){\n  medias <- c(medias, mean(df[[i]], na.rm=TRUE))\n}\nmedias\n\n[1] 5.820000 6.016667\n\n\n\n\n\ncrear una nueva columna con la calificación (suspenso, aprobado, notable, sobresaliente) de las notas de Física y Química.\n\n\n\n\n\n\nSolución\n\n\n\n\n\n\nnombre <- c(\"Carlos\", \"María\", \"Carmen\", \"Pedro\", \"Luis\", \"Sara\")\nsexo <- c(\"H\", \"M\", \"M\", \"H\", \"H\", \"M\")\nfisica <- c(6.7, 7.2, 5.5, NA, 3.5, 6.2)\nquimica <- c(8.1, 9.5, 5, 4.5, 5, 4)\ndf <- data.frame(nombre, sexo, fisica, quimica)\n\n\nfor (i in 1:nrow(df)){\n  \n}"
  },
  {
    "objectID": "05-funciones.html#definición-y-llamada-a-funciones",
    "href": "05-funciones.html#definición-y-llamada-a-funciones",
    "title": "5  Funciones",
    "section": "5.1 Definición y llamada a funciones",
    "text": "5.1 Definición y llamada a funciones\nPara definir una función se utiliza la siguiente estructura de código:\n\nnombre.funcion <- function (parámetros) {   <código>\n}\n\nEl código que va entre llaves se conoce como cuerpo de la función.\nPara llamar a la función y que se ejecute el código de su cuerpo hay que utilizar el nombre de la función y a continuación los valores pasados a sus parámetros entre paréntesis.\n\nEjemplo 5.1 A continuación se muestra un ejemplo de creación y llamada a una función.\n\n# Definición de la función\nsaludo <- function() {\n  print(\"¡Hola!\")\n}\nclass(saludo)\n\n[1] \"function\"\n\n# Llamada a la función\nsaludo()\n\n[1] \"¡Hola!\""
  },
  {
    "objectID": "05-funciones.html#parámetros-y-argumentos-de-una-función",
    "href": "05-funciones.html#parámetros-y-argumentos-de-una-función",
    "title": "5  Funciones",
    "section": "5.2 Parámetros y argumentos de una función",
    "text": "5.2 Parámetros y argumentos de una función\nUna función puede recibir valores cuando se invoca a través de unas variables conocidas como parámetros que se definen entre paréntesis en la declaración de la función. En el cuerpo de la función se pueden usar estos parámetros como si fuesen variables.\nLos valores que se pasan a la función en una llamada o invocación concreta de ella se conocen como argumentos y se asocian a los parámetros de la declaración de la función.\n\nEjemplo 5.2 A continuación se muestra un ejemplo de una función con parámetros.\n\n# Función con un parámetro\nsaludo <- function(nombre) {\n  print(paste(\"¡Hola \", nombre, \"!\", sep = \"\"))\n}\n# Llamada a la función con un argumento\nsaludo(\"Alf\")\n\n[1] \"¡Hola Alf!\"\n\n\nEn este ejemplo la función saludo tiene un parámetro nombre. En la llamada a la función se pasa la cadena Alf como argumento que se asocia al parámetro nombre en el cuerpo de la función.\n\n\n5.2.1 Paso de argumentos a una función\nLos argumentos de una función pueden pasarse de dos formas:\n\nArgumentos posicionales: Se asocian a los parámetros de la función en el mismo orden que aparecen en la definición de la función.\nArgumentos nominales: Se indica explícitamente el nombre del parámetro al que se asocia un argumento de la forma parametro = argumento. En este caso el orden de los argumentos no importa.\n\n\nEjemplo 5.3 A continuación se muestran varios ejemplos de pasos de argumentos posicionales y nominales.\n\n# Función con un argumento por defecto\narea.triangulo <- function(base, altura) {\n  base * altura / 2\n}\n# Cálculo del área de un triángulo de base 4 y altura 3\n# Paso de argumentos por posición. \narea.triangulo(4, 3)\n\n[1] 6\n\n# Paso de argumentos por nombre\narea.triangulo(altura = 3, base = 4)\n\n[1] 6\n\n\n\n\n\n5.2.2 Argumentos por defecto\nEn la definición de una función se puede asignar a cada parámetro un argumento por defecto, de manera que si se invoca la función sin proporcionar ningún argumento para ese parámetro, se utiliza el argumento por defecto.\n\nEjemplo 5.4 A continuación se muestra un ejemplo de definición de una función con un argumento por defecto.\n\nsaludo <- function(nombre, lenguaje = \"R\") {\n  print(paste(\"¡Hola \", nombre, \"! ¡Bienvenido a \", lenguaje, \"!\", sep = \"\"))\n}\n# Llamada a la función con un argumento\nsaludo(\"Alf\")\n\n[1] \"¡Hola Alf! ¡Bienvenido a R!\""
  },
  {
    "objectID": "05-funciones.html#retorno-de-una-función",
    "href": "05-funciones.html#retorno-de-una-función",
    "title": "5  Funciones",
    "section": "5.3 Retorno de una función",
    "text": "5.3 Retorno de una función\nUna función puede devolver un objeto de cualquier tipo tras su invocación. Para ello se utiliza la función return(), indicando entre paréntesis el valor que devuelve la función. El retorno suele realizarse al final del cuerpo de la función, porque con él finaliza la ejecución de la función y se devuelve el control de la ejecución al punto desde donde se llamó a la función, de manera que cualquier instrucción de cuerpo que vaya después no se ejecutará. Si no se indica ningún objeto, la función devolverá el valor de la última expresión calculada en el cuerpo de la función.\n\nEjemplo 5.5 A continuación se muestran varios ejemplos de retornos de funciones.\n\n# Función que devuelve el area de un triángulo\narea.triangulo <- function(base, altura) {\n  return(base * altura / 2)\n}\narea.triangulo(4, 3)\n\n[1] 6\n\n# Función que devuelve el valor absoluto de un número\nvalor.absoluto <- function(x) {\n  if (x < 0)\n    return(x * -1)\n  else\n    return(x)\n}\nvalor.absoluto(-1)\n\n[1] 1\n\nvalor.absoluto(2)\n\n[1] 2\n\n\n\nPara devolver más de un valor se pueden utilizar estructuras de datos como vectores, listas, matrices o data frames.\n\nEjemplo 5.6 A continuación se muestra un ejemplo de una función de devuelve una lista.\n\ncirculo <- function(radio) {\n  return(list(perimetro = 2 * pi * radio, area = pi * radio ^ 2))\n}\ncirculo(5)\n\n$perimetro\n[1] 31.41593\n\n$area\n[1] 78.53982\n\ncirculo(5)$perimetro\n\n[1] 31.41593\n\ncirculo(5)$area\n\n[1] 78.53982"
  },
  {
    "objectID": "05-funciones.html#entorno-y-ámbito-de-las-variables",
    "href": "05-funciones.html#entorno-y-ámbito-de-las-variables",
    "title": "5  Funciones",
    "section": "5.4 Entorno y ámbito de las variables",
    "text": "5.4 Entorno y ámbito de las variables\nEl entorno de un programa en R es el conjunto de todos los objetos (funciones, variables, etc.) creados durante la ejecución del programa. Cuando se ejecuta el interprete de R siempre se crea un primer entorno R_GlobalEnv conocido como entorno global. Es posible referirse a él en cualquier momento con la constante .GlobalEnv.\nPara ver el entorno activo en cada momento de la ejecución y el contenido del mismo se utiliza la siguiente función:\n\nenvironment(): Devuelve el nombre del entorno actual.\nls(): Devuelve un vector con los nombres de las objetos (variables, funciones, etc.) que contiene el entorno global.\n\n\n\n\n\nEjemplo 5.7 A continuación se muestra un ejemplo acceso al entorno global de un programa.\n\nx <- 4\ny <- 3\narea.triangulo <- function(base, altura) {\n  base * altura / 2\n}\nenvironment()\n\n<environment: R_GlobalEnv>\n\nls()\n\n[1] \"area.triangulo\" \"x\"              \"y\"             \n\n\n\nComo se puede observar en el ejemplo anterior, los parámetros de la función base y altura no aparecen en el entorno global. En R, cuando se ejecuta una función se crea un nuevo entorno hijo dentro del entorno al que pertenece la función. Durante la ejecución de la función este pasa a ser el entorno activo y cuando termina la ejecución de la función deja de serlo y vuelve a activarse el entorno padre desde donde se llamó a la función.\n\nEjemplo 5.8 A continuación se muestra un ejemplo de activación del entorno de una función.\n\nx <- 4\ny <- 3\narea.triangulo <- function(base, altura) {\n  print(\"Entorno de la función area.triangulo\") \n  print(environment())\n  print(ls())\n  return(base * altura / 2)\n}\nprint(\"Entorno fuera de la función\")\n\n[1] \"Entorno fuera de la función\"\n\nenvironment()\n\n<environment: R_GlobalEnv>\n\nls()\n\n[1] \"area.triangulo\" \"x\"              \"y\"             \n\narea.triangulo(x, y)\n\n[1] \"Entorno de la función area.triangulo\"\n<environment: 0x5571dfa94440>\n[1] \"altura\" \"base\"  \n\n\n[1] 6\n\n\n\nLos parámetros y los objetos (funciones, variables, etc.) definidos dentro de una función son de ámbito local, mientras que los objetos definidos fuera de ella en alguno de los entornos ancestros son de ámbito global.\nTanto los parámetros como las variables del ámbito local de una función sólo están accesibles durante la ejecución de la función, es decir, cuando termina la ejecución de la función estas variables desaparecen y no son accesibles desde fuera de la función.\nCuando una función declara un objeto (función, variable, etc.) que ya existe en alguno de los entornos ancestros con ámbito global, durante la ejecución de la función el objeto global queda eclipsado por el local y no es accesible hasta que finaliza la ejecución de la función.\n\nEjemplo 5.9 A continuación se muestra un ejemplo de eclipse de una variable de ámbito global por otra de ámbito local.\n\nlenguaje = \"Python\"\nsaludo <- function(lenguaje) {\n  print(paste(\"Bienvenido a\", lenguaje))  \n}\nsaludo(\"R\")\n\n[1] \"Bienvenido a R\"\n\n\nObsérvese cómo al ejecutar la función anterior, la variable lenguaje queda inaccesible al tener la función un parámetro con el mismo nombre.\n\nLas variables globales están accesibles siempre que no sean eclipsadas por otras con el mismo nombre de ámbito local. Si embargo, cuando se intenta asignar un valor a una variable global en el ámbito local, se crea una nueva variable local. Para asignar valores a variables globales en el ámbito local se tiene que utilizar el operador de superasignación <<-. Cuando se utiliza este operador para asignar un valor a una variable, R busca la variable entorno padre, y si no existe continua con la búsqueda en los entornos ancestros hasta llegar a entorno global. Si la búsqueda tiene éxito, asigna el nuevo valor a la variable global, mientras que si no tiene éxito se crea una nueva variable de ámbito local y se le asigna el valor.\n\nEjemplo 5.10 A continuación se muestra un ejemplo del uso del operador de superasignación.\n\nsaludo <- function() {\n  lenguaje <<- \"R\"\n  return(paste(\"Bienvenido a\", lenguaje))\n}\nlenguaje\n\n[1] \"Python\""
  },
  {
    "objectID": "05-funciones.html#componentes-de-una-función",
    "href": "05-funciones.html#componentes-de-una-función",
    "title": "5  Funciones",
    "section": "5.5 Componentes de una función",
    "text": "5.5 Componentes de una función\nLos tres componentes de una función son:\n\nCuerpo: Es el código dentro de la función.\nParámetros: Es la lista de parámetros que requiere la función.\nEntorno: Es donde se ubican las variables de la función.\n\nPara acceder a estos componentes se pueden utilizar las siguientes funciones:\n\nbody(f): Devuelve el cuerpo de la función f.\nformals(f): Devuelve la lista de parámetros de la función f.\nenvironment(f): Devuelve el entorno de la función f.\n\n\nEjemplo 5.11 A continuación se muestra un ejemplo de acceso a los componentes de una función.\n\n# Definición de la función\narea.triangulo <- function(base, altura) {\n  base * altura / 2\n}\nbody(area.triangulo)\n\n{\n    base * altura/2\n}\n\nformals(area.triangulo)\n\n$base\n\n\n$altura\n\nenvironment(saludo)\n\n<environment: R_GlobalEnv>"
  },
  {
    "objectID": "05-funciones.html#funciones-recursivas",
    "href": "05-funciones.html#funciones-recursivas",
    "title": "5  Funciones",
    "section": "5.6 Funciones recursivas",
    "text": "5.6 Funciones recursivas\nUna función recursiva es una función que en su cuerpo contiene una llama a sí misma.\nLa recursión es una práctica común en la mayoría de los lenguajes de programación ya que permite resolver las tareas recursivas de manera más natural.\nPara garantizar el final de una función recursiva, las sucesivas llamadas tienen que reducir el grado de complejidad del problema, hasta que este pueda resolverse directamente sin necesidad de volver a llamar a la función. De lo contrario la recursión no tendría fin y nunca terminaría la ejecución de la función.\n\nEjemplo 5.12 A continuación se muestra un ejemplo de una función recursiva.\n\nfactorial <- function(n) {\n  if (n <= 1) return(n)\n  else return(n * factorial(n - 1))\n}\nfactorial(4)\n\n[1] 24"
  },
  {
    "objectID": "05-funciones.html#paquetes",
    "href": "05-funciones.html#paquetes",
    "title": "5  Funciones",
    "section": "5.7 Paquetes",
    "text": "5.7 Paquetes\nPara facilitar la reutilización código y datos R permite la creación de paquetes que pueden importarse desde otros programas. Un paquete es una colección de código, funciones y datos que se almacenan en un fichero dentro de un directorio llamado library en el entorno de R. Para ver la ubicación de este directorio dentro del sistema de archivos local se puede utilizar la función .libPaths().\n\nEjemplo 5.13 A continuación se muestra un ejemplo de la ubicación del directorio library.\n\n.libPaths()\n\n[1] \"/home/alf/R/x86_64-pc-linux-gnu-library/4.2\"\n[2] \"/usr/lib/R/library\"                         \n\n\n\nDurante la instalación de R también se instalan varios paquetes básicos que están disponibles en cualquier sesión de trabajo con R. Pero añadir nuevas funciones o procedimientos es necesario instalar el paquete que los contiene y después cargarlo en la sesión de trabajo.\nPara ver los paquetes instalados en un ordenador se utiliza la función library().\n\n5.7.1 Instalación de paquetes\nLa mayor parte de los paquetes para R están disponibles en el repositorio oficial CRAN (Comprehensive R Archive Network), aunque cualquier persona puede desarrollar un paquete y ponerlo a disposición de la comunidad en cualquier otro repositorio.\nExisten distintas formas de instalar un paquete en R:\n\nDirectamente desde el repositorio oficial CRAN\nDesde otros repositorios no oficiales (por ejemplo Github)\nDescargando el paquete e instalándolo manualmente.\n\n\n5.7.1.1 Instalación de paquetes desde el repositorio CRAN\nPara instalar un paquete desde el repositorio oficial CRAN se utiliza la siguiente función:\n\ninstall.packages(x): Obtiene el paquete con el nombre x desde un servidor con el repositorio CRAN y lo instala localmente en el directorio library del entorno de R. Se puede instalar más de un paquete a la vez pasando un vector con los nombres de los paquetes.\n\n\nEjemplo 5.14 A continuación se muestra un ejemplo de instalación de paquetes desde el repositorio CRAN.\n\ninstall.packages(\"devtools\")\n\n\n\n\n5.7.1.2 Instalación desde otros repositorios (GitHub, GitLab, etc.)\nEl paquete remotes incorpora funciones para instalar paquetes alojados en otros repositorios habituales para el desarrollo de software como GitHub, GitLab o Bioconductor.\n\nEjemplo 5.15 A continuación se muestra un ejemplo de instalación de paquetes desde GitHub.\n\ninstall.packages(\"remotes\")\nremotes::install_github(\"rkward-community/rk.Teaching\")\n\n\n\n\n5.7.1.3 Instalación manual\nFinalmente es posible instalar un paquete manualmente a partir de su código fuente. Para ello hay previamente hay que descargar el código fuente del paquete en un fichero comprimido en formato zip y después utilizar la siguiente función:\n\ninstall.packages(x, repos = NULL, type = \"source\"): Instala el paquete ubicado en la ruta x del sistema de archivos local en la librería library.\n\nUna vez instalado un paquete ya está disponible para cargarlo en cualquier sesión de trabajo de R y no es necesario volver a instalarlo.\n\n\n\n5.7.2 Carga de un paquete\nUna vez instalado un paquete, para poder ejecutar su contenido es necesario cargarlo en el entorno de trabajo de R. Para ello se utiliza la siguiente función:\n\nlibrary(x): Ejecuta el código del paquete x en la sesión de trabajo activa.\n\n\nEjemplo 5.16 A continuación se muestra un ejemplo de carga de un paquete.\n\nlibrary(\"remotes\")\n\n\n\n\n5.7.3 Paquetes habituales\nA continuación se presenta una lista ordenada alfabéticamente (no por importancia) de los paquetes más populares para el análisis de datos:\n\ncaret es un paquete para la creación de modelos de clasificación y regresión mediante aprendizaje automático.\ndata.table es un paquete para la manipulación de grandes conjuntos de datos (de hasta 100GB) de manera rápida y eficiente.\ndevtools es un paquete con herramientas para el desarrollo de paquetes en R.\nknitr es un paquete que proporciona un motor para la generación de informes dinámicos que permite la integración de código en R con los lenguajes de procesamiento de textos LaTeX, HTML, Markdown, AsciiDoc o reStructuredText.\nmlr3 es un paquete que proporciona funciones para las principales técnicas de aprendizaje automático.\nplotly es un paquete para la creación de gráficos interactivos.\nrmarkdown es un paquete que facilita el uso del paquete knitr para la elaboración de documentos en múltiples formatos (HTML, pdf, Word y otros) permitiendo la integración de código R en el lenguaje Markdown.\nshiny es un paquete para la construcción de aplicaciones web interactivas.\ntidymodels es una colección de paquetes para la construcción y evalucación de modelos con técnicas de aprendizaje automático.\ntidyverse es una colección de paquetes para la Ciencia de Datos que incluye paquetes para la carga, limpieza, manipulación y representación gráfica de datos."
  },
  {
    "objectID": "06-preprocesamiento.html#la-colección-de-paquetes-tidyverse",
    "href": "06-preprocesamiento.html#la-colección-de-paquetes-tidyverse",
    "title": "6  Preprocesamiento de datos",
    "section": "6.1 La colección de paquetes tidyverse",
    "text": "6.1 La colección de paquetes tidyverse\ntidyverse es una colección de paquetes para la Ciencia de Datos. Incluye los siguientes paquetes:\n\ntibble: Define la estructura de datos tibble que es una versión mejorada de los data frames.\nreadr: Proporciona funciones para la lectura y escritura de tablas de datos en formato plano csv y tsv.\ntidyr: Proporciona funciones para la limpieza y preparación de los datos de manera consistente.\ndplyr: Proporciona una gramática de funciones para la manipulación de datos y las tareas más habituales de preprocesamiento.\nstringr: Proporciona funciones especializadas en la manipulación de cadenas.\nforcats: Proporciona funciones especializadas en la manipulación de factores.\npurrr: Proporciona funciones para la programación funcional que mejoran las ya existentes en R.\nggplot2: Proporciona una gramática de funciones para la realización de gráficos.\n\nEstos paquetes están diseñados bajo una misma filosofía por lo interactúan y se complementan a la perfección."
  },
  {
    "objectID": "06-preprocesamiento.html#tibbles",
    "href": "06-preprocesamiento.html#tibbles",
    "title": "6  Preprocesamiento de datos",
    "section": "6.2 Tibbles",
    "text": "6.2 Tibbles\nEl paquete tibble define la estructura de datos tibble que es similiar a los data frames, pero optimizada, ya que realiza una carga en memoria y evaluación perezosa, lo que hace más eficiente el manejo de grandes volúmenes de datos estructurados en forma de tabla. Los tibbles, además, suelen dar más información sobre el contenido y la estructura de los datos, así como de incoherencias en los datos.\nLos tibbles nunca cambian el tipo de los datos (por ejemplo de cadenas a factores), nunca cambian los nombres de las variables, ni crean nombres de filas, como suelen hacer los data frames.\nAunque los paquetes de tidyverse trabajan perfectamente con data frames, están optimizados para trabajar con tibbles.\nPara convertir un data frame en un tibble se utiliza la función\n\nas_tibble(df): Convierte el data frame df en un tibble.\n\n\nEjemplo 6.1  \n\nlibrary(tibble)\ndf <- data.frame(asignatura = c(\"Matemáticas\", \"Física\", \"Economía\"), nota = c(8.5, 7, 4.5))\ndf\n\n   asignatura nota\n1 Matemáticas  8.5\n2      Física  7.0\n3    Economía  4.5\n\nas_tibble(df)\n\n# A tibble: 3 × 2\n  asignatura   nota\n  <chr>       <dbl>\n1 Matemáticas   8.5\n2 Física        7  \n3 Economía      4.5\n\n\n\nAl igual que los data frames, las columnas de los tibbles son vectores cuyos elementos son del mismo tipo, de manera que suelen representar variables en los estudios estadísticos, mientras que las filas representan individuos, aunque no siempre es así."
  },
  {
    "objectID": "06-preprocesamiento.html#conjuntos-de-datos-ordenados",
    "href": "06-preprocesamiento.html#conjuntos-de-datos-ordenados",
    "title": "6  Preprocesamiento de datos",
    "section": "6.3 Conjuntos de datos ordenados",
    "text": "6.3 Conjuntos de datos ordenados\nExisten dos formas habituales de disponer los datos de un estudio en un data frame o un tibble: formato ancho y formato largo.\n\n\n\nFormatos de un data frame\n\n\nLa mayoría de los paquetes de tidyverse asumen que los datos del data frame o tibble están en formado largo, lo que significa que las columnas del data frame representan variables y las filas observaciones, de manera que cada dato pertenece a una variable y una observación única. Las variables (columnas) contienen valores que miden la misma característica o atributo (edad, estatura, etc.) en cada unidad experimental. Una observación (fila) contiene los valores medidos en la misma unidad experimental (una persona, un día, etc.) en todos atributos estudiados. En resumen, un data frame o tibble esta ordenado (tidy) si\n\nCada columna es una variable\nCada fila es una observación\nCada casilla es un valor\n\nA menudo los conjuntos de datos no están ordenados y violan alguna de de estas condiciones. Lo más común es encontrarnos\n\nEncabezados de columnas que son valores en lugar de variables.\nUna misma columna contiene varias variables.\nVariables que están almacenadas tanto en filas como en columnas.\n\nPara facilitar el preprocesado y posterior análisis de los datos es recomendable ordenar el data frame. Para ello el paquete tidyr proporciona dos funciones que permiten pivotar un data frame:\n\npivot_longer(df, columnas, names_to = columna-nombres, values_to = columna-valores): Devuelve el tibble que resulta de convertir las columnas indicadas en el parámetro columnas del data frame df a formato largo, es decir, las columnas se reestructuran en dos nuevas columnas con nombres columna-nombres y columna-valores que contienen los nombres de las columnas originales y sus valores, respectivamente.\npivot_wider(df, names_from = columna-nombres, values_from = columna-valores): Devuelve el tibble que resulta de convertir el data frame df a formato ancho, es decir, se crean tantas columnas como nombres distintos haya en la columna columna-nombres, usando estos nombres como los nombres de las columnas, mientras que los valores se toman de la columna columna-valores.\n\n\n\nlibrary(tidyr)\ndf <- data.frame(nombre = c('María', 'Luis', 'Carmen'), \nedad = c(18, 22, 20), \nMatemáticas = c(8.5, 7, 3.5),\nEconomía = c(8, 6.5, 5),\nProgramación = c(6.5, 4, 9))\ndf\n\n  nombre edad Matemáticas Economía Programación\n1  María   18         8.5      8.0          6.5\n2   Luis   22         7.0      6.5          4.0\n3 Carmen   20         3.5      5.0          9.0\n\n# Pivotar de formato ancho a formato largo\ndf_largo <- pivot_longer(df, Matemáticas:Programación, names_to = \"Asignatura\", values_to = \"Nota\")\ndf_largo\n\n# A tibble: 9 × 4\n  nombre  edad Asignatura    Nota\n  <chr>  <dbl> <chr>        <dbl>\n1 María     18 Matemáticas    8.5\n2 María     18 Economía       8  \n3 María     18 Programación   6.5\n4 Luis      22 Matemáticas    7  \n5 Luis      22 Economía       6.5\n6 Luis      22 Programación   4  \n7 Carmen    20 Matemáticas    3.5\n8 Carmen    20 Economía       5  \n9 Carmen    20 Programación   9  \n\n# Pivotar de formato largo a formato ancho\ndf_ancho <- pivot_wider(df_largo, names_from = Asignatura, values_from = Nota)\ndf_ancho\n\n# A tibble: 3 × 5\n  nombre  edad Matemáticas Economía Programación\n  <chr>  <dbl>       <dbl>    <dbl>        <dbl>\n1 María     18         8.5      8            6.5\n2 Luis      22         7        6.5          4  \n3 Carmen    20         3.5      5            9"
  },
  {
    "objectID": "06-preprocesamiento.html#el-paquete-dplyr",
    "href": "06-preprocesamiento.html#el-paquete-dplyr",
    "title": "6  Preprocesamiento de datos",
    "section": "6.4 El paquete dplyr",
    "text": "6.4 El paquete dplyr\nEl paquete dplyr proporciona una gramática para el preprocesamiento de data frames o tibbles, de manera que cada acción sobre data frame se corresponde con un verbo y las funciones que realizan esa acción tienen como nombre el verbo correspondiente. Las funciones de preprocesamiento más habituales incluidas en el paquete dplyr son:\n\nselect: Selecciona un subconjunto de columnas de un data frame.\nfilter: Selecciona un subconjunto de filas de un data frame.\narrange: Reordena las filas de un data frame.\nrename: Renombra las columnas de un data frame.\nmutate: Añade nuevas columnas a un data frame o transforma las existentes.\nsummarise: Genera resúmenes estadísticos de las columnas de un data frame.\ngroup_by: Divide las filas de un data frame en grupos de acuerdo a una columna categórica."
  },
  {
    "objectID": "06-preprocesamiento.html#selección-de-variables",
    "href": "06-preprocesamiento.html#selección-de-variables",
    "title": "6  Preprocesamiento de datos",
    "section": "6.5 Selección de variables",
    "text": "6.5 Selección de variables\nPara seleccionar un subconjunto de variables de un data frame se utiliza la función\n\nselect(df, columnas): Devuelve un tibble con las columnas indicadas en el parámetro columnas del data frame df.\n\n\n\nlibrary(dplyr)\ndf <- read.csv('https://raw.githubusercontent.com/asalber/manual-r/master/datos/colesterol.csv')\n# Seleccionar las columnas nombre, sexo y edad\nselect(df, nombre, sexo, edad)\n\n                            nombre sexo edad\n1     José Luis Martínez Izquierdo    H   18\n2                   Rosa Díaz Díaz    M   32\n3            Javier García Sánchez    H   24\n4              Carmen López Pinzón    M   35\n5             Marisa López Collado    M   46\n6                Antonio Ruiz Cruz    H   68\n7          Antonio Fernández Ocaña    H   51\n8            Pilar Martín González    M   22\n9             Pedro Gálvez Tenorio    H   35\n10         Santiago Reillo Manzano    H   46\n11           Macarena Álvarez Luna    M   53\n12      José María de la Guía Sanz    H   58\n13 Miguel Angel Cuadrado Gutiérrez    H   27\n14           Carolina Rubio Moreno    M   20\n\n# Seleccionar la primera y tercera columnas\nselect(df, 1, 3)\n\n                            nombre sexo\n1     José Luis Martínez Izquierdo    H\n2                   Rosa Díaz Díaz    M\n3            Javier García Sánchez    H\n4              Carmen López Pinzón    M\n5             Marisa López Collado    M\n6                Antonio Ruiz Cruz    H\n7          Antonio Fernández Ocaña    H\n8            Pilar Martín González    M\n9             Pedro Gálvez Tenorio    H\n10         Santiago Reillo Manzano    H\n11           Macarena Álvarez Luna    M\n12      José María de la Guía Sanz    H\n13 Miguel Angel Cuadrado Gutiérrez    H\n14           Carolina Rubio Moreno    M\n\n# Seleccionar las columnas desde el peso hasta el colesterol\nselect(df, peso:colesterol)\n\n   peso altura colesterol\n1    85   1.79        182\n2    65   1.73        232\n3    NA   1.81        191\n4    65   1.70        200\n5    51   1.58        148\n6    66   1.74        249\n7    62   1.72        276\n8    60   1.66         NA\n9    90   1.94        241\n10   75   1.85        280\n11   55   1.62        262\n12   78   1.87        198\n13  109   1.98        210\n14   61   1.77        194\n\n# Seleccionar todas las columnas menos la edad\nselect(df, -edad)\n\n                            nombre sexo peso altura colesterol\n1     José Luis Martínez Izquierdo    H   85   1.79        182\n2                   Rosa Díaz Díaz    M   65   1.73        232\n3            Javier García Sánchez    H   NA   1.81        191\n4              Carmen López Pinzón    M   65   1.70        200\n5             Marisa López Collado    M   51   1.58        148\n6                Antonio Ruiz Cruz    H   66   1.74        249\n7          Antonio Fernández Ocaña    H   62   1.72        276\n8            Pilar Martín González    M   60   1.66         NA\n9             Pedro Gálvez Tenorio    H   90   1.94        241\n10         Santiago Reillo Manzano    H   75   1.85        280\n11           Macarena Álvarez Luna    M   55   1.62        262\n12      José María de la Guía Sanz    H   78   1.87        198\n13 Miguel Angel Cuadrado Gutiérrez    H  109   1.98        210\n14           Carolina Rubio Moreno    M   61   1.77        194"
  },
  {
    "objectID": "06-preprocesamiento.html#filtrado-de-datos",
    "href": "06-preprocesamiento.html#filtrado-de-datos",
    "title": "6  Preprocesamiento de datos",
    "section": "6.6 Filtrado de datos",
    "text": "6.6 Filtrado de datos\nPara filtrar un data frame y quedarse con las filas que cumplen una condición se usa la función\n\nfilter(df, condicion): Devuelve el tibble con las filas del data frame df que cumplen la condición indicada en el parámetro condición.\n\n\n\nlibrary(dplyr)\ndf <- read.csv('https://raw.githubusercontent.com/asalber/manual-r/master/datos/colesterol.csv')\n# Filtrar las mujeres\nfilter(df, sexo == \"M\")\n\n                 nombre edad sexo peso altura colesterol\n1        Rosa Díaz Díaz   32    M   65   1.73        232\n2   Carmen López Pinzón   35    M   65   1.70        200\n3  Marisa López Collado   46    M   51   1.58        148\n4 Pilar Martín González   22    M   60   1.66         NA\n5 Macarena Álvarez Luna   53    M   55   1.62        262\n6 Carolina Rubio Moreno   20    M   61   1.77        194\n\n# Filtrar los hombres mayores de 30 \nfilter(df, sexo == \"H\" & edad > 30)\n\n                      nombre edad sexo peso altura colesterol\n1          Antonio Ruiz Cruz   68    H   66   1.74        249\n2    Antonio Fernández Ocaña   51    H   62   1.72        276\n3       Pedro Gálvez Tenorio   35    H   90   1.94        241\n4    Santiago Reillo Manzano   46    H   75   1.85        280\n5 José María de la Guía Sanz   58    H   78   1.87        198\n\n# Filtrar las filas con valores de colesterol\nfilter(df, !is.na(colesterol))\n\n                            nombre edad sexo peso altura colesterol\n1     José Luis Martínez Izquierdo   18    H   85   1.79        182\n2                   Rosa Díaz Díaz   32    M   65   1.73        232\n3            Javier García Sánchez   24    H   NA   1.81        191\n4              Carmen López Pinzón   35    M   65   1.70        200\n5             Marisa López Collado   46    M   51   1.58        148\n6                Antonio Ruiz Cruz   68    H   66   1.74        249\n7          Antonio Fernández Ocaña   51    H   62   1.72        276\n8             Pedro Gálvez Tenorio   35    H   90   1.94        241\n9          Santiago Reillo Manzano   46    H   75   1.85        280\n10           Macarena Álvarez Luna   53    M   55   1.62        262\n11      José María de la Guía Sanz   58    H   78   1.87        198\n12 Miguel Angel Cuadrado Gutiérrez   27    H  109   1.98        210\n13           Carolina Rubio Moreno   20    M   61   1.77        194\n\n\n\nExiste un filtro bastante habitual que consiste en eliminar las filas de un data frame que contienen algún dado no disponible (NA). Para ello dplyr dispone de la función\n\nna.omit(df): Devuelve el tibble que resulta de eliminar las filas del data frame df con algún valor NA.\n\n\n\nna.omit(df)\n\n                            nombre edad sexo peso altura colesterol\n1     José Luis Martínez Izquierdo   18    H   85   1.79        182\n2                   Rosa Díaz Díaz   32    M   65   1.73        232\n4              Carmen López Pinzón   35    M   65   1.70        200\n5             Marisa López Collado   46    M   51   1.58        148\n6                Antonio Ruiz Cruz   68    H   66   1.74        249\n7          Antonio Fernández Ocaña   51    H   62   1.72        276\n9             Pedro Gálvez Tenorio   35    H   90   1.94        241\n10         Santiago Reillo Manzano   46    H   75   1.85        280\n11           Macarena Álvarez Luna   53    M   55   1.62        262\n12      José María de la Guía Sanz   58    H   78   1.87        198\n13 Miguel Angel Cuadrado Gutiérrez   27    H  109   1.98        210\n14           Carolina Rubio Moreno   20    M   61   1.77        194"
  },
  {
    "objectID": "06-preprocesamiento.html#reordenación-de-datos",
    "href": "06-preprocesamiento.html#reordenación-de-datos",
    "title": "6  Preprocesamiento de datos",
    "section": "6.7 Reordenación de datos",
    "text": "6.7 Reordenación de datos\nPara reordenar las filas de un data frame se utiliza la función\n\narrange(df, columnas): Devuelve un tibble con las mismas filas del data frame df pero ordenadas de acuerdo a los valores de las columnas indicadas en el parámetro columnas. Por defecto, la ordenación es ascendente, para hacerla descendente, hay que aplicar la función desc() a la columna con respecto se quiere ordenar descendentemente.\n\n\n\nlibrary(dplyr)\ndf <- read.csv('https://raw.githubusercontent.com/asalber/manual-r/master/datos/colesterol.csv')\n# Ordenar según alfabéticamente por nombre\narrange(df, nombre)\n\n                            nombre edad sexo peso altura colesterol\n1          Antonio Fernández Ocaña   51    H   62   1.72        276\n2                Antonio Ruiz Cruz   68    H   66   1.74        249\n3              Carmen López Pinzón   35    M   65   1.70        200\n4            Carolina Rubio Moreno   20    M   61   1.77        194\n5            Javier García Sánchez   24    H   NA   1.81        191\n6     José Luis Martínez Izquierdo   18    H   85   1.79        182\n7       José María de la Guía Sanz   58    H   78   1.87        198\n8            Macarena Álvarez Luna   53    M   55   1.62        262\n9             Marisa López Collado   46    M   51   1.58        148\n10 Miguel Angel Cuadrado Gutiérrez   27    H  109   1.98        210\n11            Pedro Gálvez Tenorio   35    H   90   1.94        241\n12           Pilar Martín González   22    M   60   1.66         NA\n13                  Rosa Díaz Díaz   32    M   65   1.73        232\n14         Santiago Reillo Manzano   46    H   75   1.85        280\n\n# Ordenar según sexo y edad\narrange(df, sexo, edad)\n\n                            nombre edad sexo peso altura colesterol\n1     José Luis Martínez Izquierdo   18    H   85   1.79        182\n2            Javier García Sánchez   24    H   NA   1.81        191\n3  Miguel Angel Cuadrado Gutiérrez   27    H  109   1.98        210\n4             Pedro Gálvez Tenorio   35    H   90   1.94        241\n5          Santiago Reillo Manzano   46    H   75   1.85        280\n6          Antonio Fernández Ocaña   51    H   62   1.72        276\n7       José María de la Guía Sanz   58    H   78   1.87        198\n8                Antonio Ruiz Cruz   68    H   66   1.74        249\n9            Carolina Rubio Moreno   20    M   61   1.77        194\n10           Pilar Martín González   22    M   60   1.66         NA\n11                  Rosa Díaz Díaz   32    M   65   1.73        232\n12             Carmen López Pinzón   35    M   65   1.70        200\n13            Marisa López Collado   46    M   51   1.58        148\n14           Macarena Álvarez Luna   53    M   55   1.62        262\n\n# Ordenar ascendentemente por sexo y descendentemente por colesterol\narrange(df, sexo, desc(colesterol))\n\n                            nombre edad sexo peso altura colesterol\n1          Santiago Reillo Manzano   46    H   75   1.85        280\n2          Antonio Fernández Ocaña   51    H   62   1.72        276\n3                Antonio Ruiz Cruz   68    H   66   1.74        249\n4             Pedro Gálvez Tenorio   35    H   90   1.94        241\n5  Miguel Angel Cuadrado Gutiérrez   27    H  109   1.98        210\n6       José María de la Guía Sanz   58    H   78   1.87        198\n7            Javier García Sánchez   24    H   NA   1.81        191\n8     José Luis Martínez Izquierdo   18    H   85   1.79        182\n9            Macarena Álvarez Luna   53    M   55   1.62        262\n10                  Rosa Díaz Díaz   32    M   65   1.73        232\n11             Carmen López Pinzón   35    M   65   1.70        200\n12           Carolina Rubio Moreno   20    M   61   1.77        194\n13            Marisa López Collado   46    M   51   1.58        148\n14           Pilar Martín González   22    M   60   1.66         NA"
  },
  {
    "objectID": "06-preprocesamiento.html#renombrado-de-columnas",
    "href": "06-preprocesamiento.html#renombrado-de-columnas",
    "title": "6  Preprocesamiento de datos",
    "section": "6.8 Renombrado de columnas",
    "text": "6.8 Renombrado de columnas\nPara cambiar el nombre de las columnas se utiliza la función\n\nrename(df, nuevo-nombre = columna): Devuelve un tibble con los mismos datos del data frame df pero cambiando el nombre de la columna de nombre columna por nuevo-nombre.\n\n\n\nlibrary(dplyr)\ndf <- read.csv('https://raw.githubusercontent.com/asalber/manual-r/master/datos/colesterol.csv')\n# Ordenar según alfabéticamente por nombre\nrename(df, estatura = altura)\n\n                            nombre edad sexo peso estatura colesterol\n1     José Luis Martínez Izquierdo   18    H   85     1.79        182\n2                   Rosa Díaz Díaz   32    M   65     1.73        232\n3            Javier García Sánchez   24    H   NA     1.81        191\n4              Carmen López Pinzón   35    M   65     1.70        200\n5             Marisa López Collado   46    M   51     1.58        148\n6                Antonio Ruiz Cruz   68    H   66     1.74        249\n7          Antonio Fernández Ocaña   51    H   62     1.72        276\n8            Pilar Martín González   22    M   60     1.66         NA\n9             Pedro Gálvez Tenorio   35    H   90     1.94        241\n10         Santiago Reillo Manzano   46    H   75     1.85        280\n11           Macarena Álvarez Luna   53    M   55     1.62        262\n12      José María de la Guía Sanz   58    H   78     1.87        198\n13 Miguel Angel Cuadrado Gutiérrez   27    H  109     1.98        210\n14           Carolina Rubio Moreno   20    M   61     1.77        194"
  },
  {
    "objectID": "06-preprocesamiento.html#creación-de-nuevas-columnas-o-transformación-de-las-existentes",
    "href": "06-preprocesamiento.html#creación-de-nuevas-columnas-o-transformación-de-las-existentes",
    "title": "6  Preprocesamiento de datos",
    "section": "6.9 Creación de nuevas columnas o transformación de las existentes",
    "text": "6.9 Creación de nuevas columnas o transformación de las existentes\nPara crear una nueva columna a partir de otras columnas del data frame se utiliza la función\n\nmutate(df, columna = formula): Devuelve el tibble que resulta de añadir una nueva columna al data frame df con el resultado de aplicar el procedimiento indicado por formula y con el nombre indicado en columna. Si columna es el nombre de una columna ya existente, entonces esa columna se reescribe con los resultados de aplicar la formula.\n\n\n\nlibrary(dplyr)\ndf <- read.csv('https://raw.githubusercontent.com/asalber/manual-r/master/datos/colesterol.csv')\n# Cambiar las unidades de la altura a centímetros\nmutate(df, altura = altura*100)\n\n                            nombre edad sexo peso altura colesterol\n1     José Luis Martínez Izquierdo   18    H   85    179        182\n2                   Rosa Díaz Díaz   32    M   65    173        232\n3            Javier García Sánchez   24    H   NA    181        191\n4              Carmen López Pinzón   35    M   65    170        200\n5             Marisa López Collado   46    M   51    158        148\n6                Antonio Ruiz Cruz   68    H   66    174        249\n7          Antonio Fernández Ocaña   51    H   62    172        276\n8            Pilar Martín González   22    M   60    166         NA\n9             Pedro Gálvez Tenorio   35    H   90    194        241\n10         Santiago Reillo Manzano   46    H   75    185        280\n11           Macarena Álvarez Luna   53    M   55    162        262\n12      José María de la Guía Sanz   58    H   78    187        198\n13 Miguel Angel Cuadrado Gutiérrez   27    H  109    198        210\n14           Carolina Rubio Moreno   20    M   61    177        194\n\n# Calcular el índice de masa corporal\nmutate(df, imc = round(peso/altura^2))\n\n                            nombre edad sexo peso altura colesterol imc\n1     José Luis Martínez Izquierdo   18    H   85   1.79        182  27\n2                   Rosa Díaz Díaz   32    M   65   1.73        232  22\n3            Javier García Sánchez   24    H   NA   1.81        191  NA\n4              Carmen López Pinzón   35    M   65   1.70        200  22\n5             Marisa López Collado   46    M   51   1.58        148  20\n6                Antonio Ruiz Cruz   68    H   66   1.74        249  22\n7          Antonio Fernández Ocaña   51    H   62   1.72        276  21\n8            Pilar Martín González   22    M   60   1.66         NA  22\n9             Pedro Gálvez Tenorio   35    H   90   1.94        241  24\n10         Santiago Reillo Manzano   46    H   75   1.85        280  22\n11           Macarena Álvarez Luna   53    M   55   1.62        262  21\n12      José María de la Guía Sanz   58    H   78   1.87        198  22\n13 Miguel Angel Cuadrado Gutiérrez   27    H  109   1.98        210  28\n14           Carolina Rubio Moreno   20    M   61   1.77        194  19"
  },
  {
    "objectID": "06-preprocesamiento.html#resumen-de-datos",
    "href": "06-preprocesamiento.html#resumen-de-datos",
    "title": "6  Preprocesamiento de datos",
    "section": "6.10 Resumen de datos",
    "text": "6.10 Resumen de datos\nPara aplicar una función resumen a una o varias columnas de un data frame se utiliza la función\n\nsumarise(df, nombre-columna = funcion-resumen(columnas)): Devuelve el tibble con la columna de nombre nombre-columna y el valor que resulta de aplicar la función indicada en funcion-resumen a las columnas del data frame df indicadas en columnas.\n\n\n\nlibrary(dplyr)\ndf <- read.csv('https://raw.githubusercontent.com/asalber/manual-r/master/datos/colesterol.csv')\n# Calcular la media de la edad\nsummarise(df, edad_media = mean(edad))\n\n  edad_media\n1   38.21429\n\n# Calcular la media y la desviación típica del colesterol\nsummarise(df, media = mean(colesterol, na.rm=T), sd = sd(colesterol, na.rm=T))\n\n     media       sd\n1 220.2308 39.84795"
  },
  {
    "objectID": "06-preprocesamiento.html#resúmenes-por-grupos",
    "href": "06-preprocesamiento.html#resúmenes-por-grupos",
    "title": "6  Preprocesamiento de datos",
    "section": "6.11 Resúmenes por grupos",
    "text": "6.11 Resúmenes por grupos\nLa función summarise suele combinarse con la siguiente función para obtener resúmenes estratificados por grupos.\n\ngroup_by(df, columnas): Devuelve un tibble estratificado de acuerdo a las categorías de las columnas indicadas en columnas. En combinación con la función summarise permite hacer resúmenes estadísticos por grupos.\n\n\n\nlibrary(dplyr)\ndf <- read.csv('https://raw.githubusercontent.com/asalber/manual-r/master/datos/colesterol.csv')\n# Estratificar por sexo \ndf.sexo <- group_by(df, sexo)\n# Edades medias por sexo\nsummarise(df.sexo, edad_media = mean(edad))\n\n# A tibble: 2 × 2\n  sexo  edad_media\n  <chr>      <dbl>\n1 H           40.9\n2 M           34.7\n\n# Media y desviación típica del colesterol por sexo\nsummarise(df.sexo, media = mean(colesterol, na.rm=T), sd = sd(colesterol, na.rm=T))\n\n# A tibble: 2 × 3\n  sexo  media    sd\n  <chr> <dbl> <dbl>\n1 H      228.  38.4\n2 M      207.  42.9"
  },
  {
    "objectID": "06-preprocesamiento.html#ejercicios",
    "href": "06-preprocesamiento.html#ejercicios",
    "title": "6  Preprocesamiento de datos",
    "section": "6.12 Ejercicios",
    "text": "6.12 Ejercicios\n\nDado el fichero de datos genetica, realizar la siguientes operaciones de preprocesado.\n\n\nCrear un tibble con los datos del fichero.\n\n\n\n\n\n\n\nSolución\n\n\n\n\n\n\nlibrary(tidyverse)\ndf <- read_csv('https://raw.githubusercontent.com/asalber/manual-r/master/datos/genetica.csv')\ndf\n\n# A tibble: 21 × 36\n   `código muestra` `nivel del fac…` `mas cor (g)` `ln(mc+1)`    IHS `logit IHS`\n   <chr>                       <dbl>         <dbl>      <dbl>  <dbl>       <dbl>\n 1 Ct-A1                           1          236        5.47 0.0433       -3.09\n 2 Ct-A2                           1          202.       5.32 0.044        -3.08\n 3 Ct-B1                           1          246.       5.51 0.042        -3.13\n 4 Ct-B2                           1          237.       5.47 0.0475       -3   \n 5 Ct-B3                           1          231.       5.45 0.0499       -2.95\n 6 Ct-C1                           1          235.       5.46 0.05         -2.94\n 7 Ct-C2                           1          228.       5.43 0.05         -2.94\n 8 Dx-1                            2          181.       5.2  0.061        -2.73\n 9 Dx-2                            2          198.       5.29 0.063        -2.7 \n10 Dx-3                            2          201.       5.31 0.0577       -2.79\n# … with 11 more rows, and 30 more variables: IES <dbl>, `logit IES` <dbl>,\n#   ITS <dbl>, `logit ITS` <dbl>, IAS <dbl>, `logit IAS` <dbl>,\n#   `glucog(mg/g)` <dbl>, `ln(glucog+1)` <dbl>, `pbmc(cel/mL)` <dbl>,\n#   `ln(pbmc+1)` <dbl>, `CD4(cel/µL)` <dbl>, `ln(CD4+1)` <dbl>,\n#   `monoc(cel/mL)` <dbl>, `ln(mon+1)` <dbl>, `IHQ: linfB(cel/mm2)` <dbl>,\n#   `ln(Q.B+1)` <dbl>, `pulp.blan(Tx1)` <dbl>, `logit P.B` <dbl>,\n#   `microorg(log nº/g)` <dbl>, `AI2(absorb)` <dbl>, `gluc(mmol/L)` <dbl>, …\n\n\n\n\n\n\nConvertir el tratamiento en un factor."
  },
  {
    "objectID": "07-graficos.html#gramática-de-gráficos-y-el-paquete-ggplot2",
    "href": "07-graficos.html#gramática-de-gráficos-y-el-paquete-ggplot2",
    "title": "7  Gráficos y visualización de datos",
    "section": "7.1 Gramática de gráficos y el paquete ggplot2",
    "text": "7.1 Gramática de gráficos y el paquete ggplot2\nEl paquete ggplot2 forma parte de la colección de paquetes tidyverse que ya se introdujo en la sección anterior.\nEste paquete implementa la gramática de gráficos descrita por Leland Wilkinson, que proporciona un sistema formal para representar distintas variables mediante distintos atributos gráficos (aesthetics) como la forma, el tamaño o el color de objetos geométricos como puntos, líneas o barras. Esto hace que la creación de gráficos con este paquete sea, en general, más intuitiva una vez se entiende la lógica de la gramática.\nEn general, para definir un gráfico con ggplot2 se suelen definir los siguientes elementos:\n\nDatos. Los datos deben estar contenidos en un data frame o tibble en formato ordenado (tidy).\nAtributos (aesthetics). Las variables que quieren representarse en el gráfico deben asociarse a atributos gráficos como los ejes x, y, z, el color, el tamaño, la forma de los objetos geométricos.\nCapas de objetos geométricos (geoms). Están formadas por elementos geométricos (puntos, líneas, barras, etc.) cuya posición, forma, tamaño y color, depende de los atributos.\nEscalas. Definen la escala para los ejes del diagrama así como las leyendas para el resto de atributos.\nSistema de coordenadas. Describe el sistema de coordenadas utilizado para representar los objetos geométricos en el plano o en el espacio (normalmente el sistema cartesiano).\nFacetas. Permite descomponer un gráfico en múltiples gráficos para distintos subconjuntos del conjunto de datos.\nTema. Permite cambiar elementos secundarios del gráfico como el tipo de letra de las etiquetas y leyendas, el tamaño de la fuente, el color de fondo, aspecto final del los gráficos.\n\nEstos elementos se suelen añadir por capas al gráfico mediante el operador +."
  },
  {
    "objectID": "07-graficos.html#inicialización-de-un-gráfico",
    "href": "07-graficos.html#inicialización-de-un-gráfico",
    "title": "7  Gráficos y visualización de datos",
    "section": "7.2 Inicialización de un gráfico",
    "text": "7.2 Inicialización de un gráfico\nPara dibujar un gráfico con ggplot2 debemos comenzar por la siguiente función\n\nggplot(df, aes(atributo1 = var1, atributo2 = var2, ...)): Inicializa un gráfico con las variables var1, var2, etc. del data frame df asociadas a los atributos atributo1, atributo2, etc. respectivamente. Los atributos pueden más comunes son:\n\nx: Posición en el eje x del objeto geométrico.\ny: Posición en el eje y del objeto geométrico.\nz: Posición en el eje z del objeto geométrico.\nshape: Forma del punto.\nsize: Tamaño del punto.\nlinetype: Forma de la línea.\nlinewidth: Anchura de la línea.\ncolour: Color del objeto geométrico.\nfill: Color de relleno del objeto geométrico.\n\n\n\n\n\n\n\n\nImportante\n\n\n\nTodos los atributos se indican dentro de la función aes()."
  },
  {
    "objectID": "07-graficos.html#diagramas-de-puntos",
    "href": "07-graficos.html#diagramas-de-puntos",
    "title": "7  Gráficos y visualización de datos",
    "section": "7.3 Diagramas de puntos",
    "text": "7.3 Diagramas de puntos\nPara dibujar un diagrama de puntos se utiliza la capa de objetos geométricos\n\ngeom_point(): Dibuja un diagrama de líneas que unen los puntos con coordenadas dadas por los pares de valores de las variables asociadas a los atributos x e y.\n\nEsta capa es ideal para representar diagramas de dispersión.\n\n\nlibrary(dplyr)\nlibrary(ggplot2)\ndf <- read.csv('https://raw.githubusercontent.com/asalber/manual-r/master/datos/temperaturas.csv') %>%\n    mutate(Día = factor(Día, levels = c(\"L\", \"M\", \"X\", \"J\", \"V\", \"S\", \"D\")))\n# Filtrar los datos de Madrid\ndf.madrid = filter(df, Ciudad == \"Madrid\")\n# Inicializar el gráfico con el día en el atributo x y la temperatura en el atributo y.\nggplot(df.madrid, aes(x = Día, y = Temperatura)) +\n# Añadir la capa de los puntos.\n    geom_point()\n\n\n\n\n\n\n\n# Inicializar el gráfico con el día en el atributo x, la temperatura en el atributo y, y la ciudad en el atributo shape.\nggplot(df, aes(x = Día, y = Temperatura, shape = Ciudad)) +\n# Añadir la capa de los puntos.\n    geom_point()\n\n\n\n\n\n\n\n# Inicializar el gráfico con el día en el atributo x, la temperatura en el atributo y, y la ciudad en el atributo colour.\nggplot(df, aes(x = Día, y = Temperatura, colour = Ciudad)) +\n# Añadir la capa de los puntos.\n    geom_point()\n\n\n\n\n\n\n\nlibrary(ggplot2)\ndf <- read.csv('https://raw.githubusercontent.com/asalber/manual-r/master/datos/colesterol.csv')\n# Inicializar el gráfico con la altura en el atributo x y el peso en el atributo y.\nggplot(df, aes(x = altura, y = peso)) +\n# Añadir la capa de los puntos.\n    geom_point()\n\nWarning: Removed 1 rows containing missing values (geom_point).\n\n\n\n\n\n\n\n\n# Inicializar el gráfico con la altura en el atributo x, el peso en el atributo y, y el sexo en el atributo colour.\nggplot(df, aes(x = altura, y = peso, colour = sexo)) +\n# Añadir la capa de los puntos.\n    geom_point()\n\nWarning: Removed 1 rows containing missing values (geom_point).\n\n\n\n\n\n\nMás información sobre geom_point."
  },
  {
    "objectID": "07-graficos.html#diagramas-de-líneas",
    "href": "07-graficos.html#diagramas-de-líneas",
    "title": "7  Gráficos y visualización de datos",
    "section": "7.4 Diagramas de líneas",
    "text": "7.4 Diagramas de líneas\nPara dibujar un diagrama de líneas se utiliza la capa de objetos geométricos\n\ngeom_line(): Dibuja un diagrama de líneas que unen los puntos con coordenadas dadas por los pares de valores de las variables asociadas a los atributos x e y. Cuando la variable asociada al atributo x es un factor, debe asociarse también una variable al atributo group para determina los grupos que se unirán mediante líneas. Si solo hay un grupo debe indicarse group = 1.\n\nEsta capa es ideal para representar series temporales.\n\n\nlibrary(dplyr)\nlibrary(ggplot2)\ndf <- read.csv('https://raw.githubusercontent.com/asalber/manual-r/master/datos/temperaturas.csv') %>%\n    mutate(Día = factor(Día, levels = c(\"L\", \"M\", \"X\", \"J\", \"V\", \"S\", \"D\")))\n# Filtrar los datos de Madrid\ndf.madrid = filter(df, Ciudad == \"Madrid\")\n# Inicializar el gráfico con el día en el atributo x y la temperatura en el atributo y. \nggplot(df.madrid, aes(x = Día, y = Temperatura, group = 1)) +\n# Añadir la capa de las lineas.\n    geom_line()\n\n\n\n\n\n\n\n# Inicializar el gráfico con el día en el atributo x, la temperatura en el atributo y, y la ciudad en los atributos group y linetype.\nggplot(df, aes(x = Día, y = Temperatura, group = Ciudad, linetype = Ciudad)) +\n# Añadir la capa de las lineas.\n    geom_line()\n\n\n\n\n\n\n\n# Inicializar el gráfico con el día en el atributo x, la temperatura en el atributo y, y la ciudad en los atributos group y colour.\nggplot(df, aes(x = Día, y = Temperatura, group = Ciudad, colour = Ciudad)) +\n# Añadir la capa de las lineas.\n    geom_line()\n\n\n\n\n\nMás información sobre geom_line."
  },
  {
    "objectID": "07-graficos.html#diagramas-de-barras",
    "href": "07-graficos.html#diagramas-de-barras",
    "title": "7  Gráficos y visualización de datos",
    "section": "7.5 Diagramas de barras",
    "text": "7.5 Diagramas de barras\nPara dibujar un diagrama de barras se utiliza la capa de objetos geométricos\n\ngeom_bar(aes(weight = var)): Dibuja un diagrama de barras con la variable asociada al atributo x o y (si se usa el atributo x las barras son verticales y se usa y horizontales), donde la altura de las barras viene dada por la variable var. Si no se indica Por defecto, la altura de las barras representa la frecuencia absoluta de cada valor de la variable. Si no se indica el atributo weight la altura de las barras es la frecuencia absoluta de los valores de la variable asociada a los atributos x o y.\n\n\n\nlibrary(dplyr)\nlibrary(ggplot2)\ndf <- read.csv('https://raw.githubusercontent.com/asalber/manual-r/master/datos/temperaturas.csv') %>%\n    mutate(Día = factor(Día, levels = c(\"L\", \"M\", \"X\", \"J\", \"V\", \"S\", \"D\")))\ndf\n\n      Ciudad Día Temperatura\n1     Madrid   L        28.5\n2     Madrid   M        30.5\n3     Madrid   X        31.0\n4     Madrid   J        30.0\n5     Madrid   V        28.0\n6     Madrid   S        27.5\n7     Madrid   D        30.5\n8  Barcelona   L        24.5\n9  Barcelona   M        25.5\n10 Barcelona   X        26.5\n11 Barcelona   J        25.0\n12 Barcelona   V        26.5\n13 Barcelona   S        24.5\n14 Barcelona   D        25.0\n\n# Filtrar los datos de Madrid\ndf.madrid = filter(df, Ciudad == \"Madrid\")\n# Inicializar el gráfico con el día en el atributo x.\nggplot(df.madrid, aes(x = Día)) +\n# Añadir la capa de las barras con altura la temperatura.\n    geom_bar(aes(weight = Temperatura))\n\n\n\n\n\n\n\n# Inicializar el gráfico con el día en el atributo y.\nggplot(df.madrid, aes(y = Día)) +\n# Añadir la capa de las barras con altura la temperatura.\n    geom_bar(aes(weight = Temperatura))\n\n\n\n\n\n\n\n# Inicializar el gráfico con el día en el atributo x y la ciudad en el color de relleno.\nggplot(df, aes(x = Día, fill = Ciudad)) +\n# Añadir la capa de las barras con altura la temperatura (por defecto barras acumuladas).\n    geom_bar(aes(weight = Temperatura))\n\n\n\n\n\n\n\n# Inicializar el gráfico con el día en el atributo x y la ciudad en el color de relleno.\nggplot(df, aes(x = Día, fill = Ciudad)) +\n# Añadir la capa de las barras con altura la temperatura indicando barras separadas.\n    geom_bar(aes(weight = Temperatura), position = \"dodge\")\n\n\n\n\n\n\n\nlibrary(ggplot2)\ndf <- read.csv('https://raw.githubusercontent.com/asalber/manual-r/master/datos/colesterol.csv')\n# Inicializar el gráfico con el sexo en el atributo x.\nggplot(df, aes(x = sexo)) +\n# Añadir la capa de las barras.\n    geom_bar()\n\n\n\n\n\n\n\n# Inicializar el gráfico con el sexo en los atributos x y fill.\nggplot(df, aes(x = sexo, fill = sexo)) +\n# Añadir la capa de las barras.\n    geom_bar() \n\n\n\n\n\nMás información sobre geom_bar."
  },
  {
    "objectID": "07-graficos.html#histogramas",
    "href": "07-graficos.html#histogramas",
    "title": "7  Gráficos y visualización de datos",
    "section": "7.6 Histogramas",
    "text": "7.6 Histogramas\nPara dibujar un histograma se utiliza la capa de objetos geométricos\n\ngeom_histogram(bins = clases, bindwidth = anchura): Dibuja un histograma de la variable asociada al atributo x usando el número de clases indicado por clases o bien clases de amplitud indicada por anchura. Si no se indica el parámetro bins o bindwidth se toman 30 clases por defecto.\n\n\n\nlibrary(ggplot2)\ndf <- read.csv('https://raw.githubusercontent.com/asalber/manual-r/master/datos/colesterol.csv')\n# Inicializar el gráfico con la edad en el atributo x.\nggplot(df, aes(x = edad)) +\n# Añadir la capa del histograma.\n    geom_histogram()\n\n\n\n\n\n\n\n# Inicializar el gráfico con la edad en el atributo x.\nggplot(df, aes(x = edad)) +\n# Añadir la capa del histograma con anchura de clases 5.\n    geom_histogram(binwidth = 5)\n\n\n\n\n\n\n\n# Inicializar el gráfico con la edad en el atributo x y el sexo en el atributo fill.\nggplot(df, aes(x = edad, fill = sexo)) +\n# Añadir la capa del histograma con anchura de clases 10.\n    geom_histogram(binwidth = 10)\n\n\n\n\n\nMás información sobre geom_histogram."
  },
  {
    "objectID": "07-graficos.html#diagramas-de-densidad",
    "href": "07-graficos.html#diagramas-de-densidad",
    "title": "7  Gráficos y visualización de datos",
    "section": "7.7 Diagramas de densidad",
    "text": "7.7 Diagramas de densidad\nPara dibujar un diagrama de densidad se utiliza la capa de objetos geométricos\n\ngeom_density(): Dibuja un diagrama de densidad de probabilidad estimada de los valores de la variable asociada al atributo x.\n\nEste diagrama es una alternativa a los histogramas para representar la distribución de probabilidad de los valores de una variable.\n\n\nlibrary(ggplot2)\ndf <- read.csv('https://raw.githubusercontent.com/asalber/manual-r/master/datos/colesterol.csv')\n# Inicializar el gráfico con la edad en el atributo x.\nggplot(df, aes(x = edad)) +\n# Añadir la capa de la densidad de probabilidad.\n    geom_density()\n\n\n\n\n\n\n\n# Inicializar el gráfico con la edad en el atributo x y el sexo en el atributo colour.\nggplot(df, aes(x = edad, colour = sexo)) +\n# Añadir la capa de la densidad de probabilidad.\n    geom_density()\n\n\n\n\n\nMás información sobre geom_density."
  },
  {
    "objectID": "07-graficos.html#diagramas-de-cajas",
    "href": "07-graficos.html#diagramas-de-cajas",
    "title": "7  Gráficos y visualización de datos",
    "section": "7.8 Diagramas de cajas",
    "text": "7.8 Diagramas de cajas\nPara dibujar un diagrama de caja y bigotes se utiliza la capa de objetos geométricos\n\ngeom_boxplot(): Dibuja un diagrama de caja y bigotes de la variable asociada al atributo x o y. Si se utiliza el atributo x la caja se representa horizontalmente, y si se utiliza el atributo y verticalmente.\n\n\n\nlibrary(ggplot2)\ndf <- read.csv('https://raw.githubusercontent.com/asalber/manual-r/master/datos/colesterol.csv')\n# Inicializar el gráfico con el colesterol en el atributo x.\nggplot(df, aes(x = colesterol)) +\n# Añadir la capa de la caja.\n    geom_boxplot()\n\nWarning: Removed 1 rows containing non-finite values (stat_boxplot).\n\n\n\n\n\n\n\n\n# Inicializar el gráfico con la altura en el atributo y y el sexo en el atributo fill.\nggplot(df, aes(y = altura, fill = sexo)) +\n# Añadir la capa de la caja.\n    geom_boxplot()\n\n\n\n\n\nMás información sobre geom_boxplot."
  },
  {
    "objectID": "07-graficos.html#diagrama-de-sectores",
    "href": "07-graficos.html#diagrama-de-sectores",
    "title": "7  Gráficos y visualización de datos",
    "section": "7.9 Diagrama de sectores",
    "text": "7.9 Diagrama de sectores\nPara dibujar un diagrama de sectores se utiliza la misma capa de objetos geométricos que para los diagramas de barras (geom_bar) pero añadiendo el sistema de coordenadas polares.\n\ncoor_polar(theta = \"x\"|\"y\"): Cambia al sistema de coordenadas cartesianas polares, donde el ángulo viene dado por la variable asociada al atributo “x” o el atributo “y”.\n\n\n\nlibrary(ggplot2)\ndf <- read.csv('https://raw.githubusercontent.com/asalber/manual-r/master/datos/colesterol.csv')\n# Inicializar el gráfico con el sexo en el atributo x.\nggplot(df, aes(x = factor(1), fill = sexo)) +\n# Añadir la capa de las barras.\n    geom_bar() +\n# Añadir el sistema de coordenadas polares\n    coord_polar(theta = \"y\")"
  },
  {
    "objectID": "07-graficos.html#interpolación-y-ajustes-de-regresión",
    "href": "07-graficos.html#interpolación-y-ajustes-de-regresión",
    "title": "7  Gráficos y visualización de datos",
    "section": "7.10 Interpolación y ajustes de regresión",
    "text": "7.10 Interpolación y ajustes de regresión\nPara dibujar una línea de interpolación o de ajuste de regresión se utiliza la capa de objetos geométricos\n\ngeom_smooth(method = ajuste, formula = ecuación): Dibuja una línea de ajuste para los puntos con coordenadas dadas por los pares de valores de las variables asociadas a los atributos x e y, usando el método de ajuste dado por por ajuste y la fórmula dada por ecuación. Los métodos de ajuste más habituales son:\n\n\"loess\": Ajuste de regresión polinomial local. Es la que se utiliza por defecto.\n\"lm\": Ajuste de regresión de modelos lineal por mínimos cuadrados.\n\"glm\": Ajuste de regresión modelos lineales generalizados por mínimos cuadrados. Por defecto se dibujan también las bandas con el error estándar del ajuste. Para desactivar estas bandas se debe indicar también el parámetro se = FALSE.\n\n\nEsta capa suele usarse en combinación con la capa de puntos para diagramas de dispersión.\n\n\nlibrary(ggplot2)\ndf <- read.csv('https://raw.githubusercontent.com/asalber/manual-r/master/datos/colesterol.csv')\n# Inicializar el gráfico con la altura en el atributo x y el peso en el atributo y.\nggplot(df, aes(x = altura, y = peso)) +\n# Añadir la capa de puntos.\n    geom_point() +\n# Añadir la capa de ajuste de regresión polinomial local loess\n    geom_smooth()\n\n\n\n\n\n\n\n# Inicializar el gráfico con la altura en el atributo x y el peso en el atributo y.\nggplot(df, aes(x = altura, y = peso)) +\n# Añadir la capa de puntos.\n    geom_point() +\n# Añadir la capa de ajuste de regresión lineal por mínimos cuadrados.\n    geom_smooth(method = \"lm\")\n\n\n\n\n\n\n\n# Inicializar el gráfico con la altura en el atributo x, el peso en el atributo y, y el sexo en el atributo colour.\nggplot(df, aes(x = altura, y = peso, colour = sexo)) +\n# Añadir la capa de puntos.\n    geom_point() +\n# Añadir la capa de ajuste de regresión lineal por mínimos cuadrados sin las bandas de error.\n    geom_smooth(method = \"lm\", se = FALSE)\n\n\n\n\n\nMás información sobre geom_smooth."
  },
  {
    "objectID": "07-graficos.html#facetas",
    "href": "07-graficos.html#facetas",
    "title": "7  Gráficos y visualización de datos",
    "section": "7.11 Facetas",
    "text": "7.11 Facetas\nLas facetas permiten desagregar un gráfico según los grupos de uno o varios factores del conjunto de datos. Para añadir facetas a un gráfico se añade la función\n\nfacet_wrap(vars(var1, var2,...), nrow = n, ncol = m): Crea un un gráfico para cada combinación de valores de las variables var1, var2, etc. y los coloca en una tabla de n filas y m columnas.\n\n\n\nlibrary(ggplot2)\ndf <- read.csv('https://raw.githubusercontent.com/asalber/manual-r/master/datos/colesterol.csv')\n# Inicializar el gráfico con la altura en el atributo x y el peso en el atributo y.\nggplot(df, aes(x = altura, y = peso)) +\n# Añadir la capa de puntos\n    geom_point() +\n# Añadir la capa de ajuste de regresión lineal por mínimos cuadrados.\n    geom_smooth(method = \"lm\") +\n# Añadir la faceta del sexo.\n    facet_wrap(vars(sexo))\n\n\n\n\n\nMás información sobre facetas."
  },
  {
    "objectID": "07-graficos.html#personalización-de-gráficos",
    "href": "07-graficos.html#personalización-de-gráficos",
    "title": "7  Gráficos y visualización de datos",
    "section": "7.12 Personalización de gráficos",
    "text": "7.12 Personalización de gráficos\nggplot incluye multitud de posibilidades de personalización de gráficos. Aquí veremos solo las más habituales.\n\n7.12.1 Títulos\nPara poner un título al gráfico, a los ejes o a la leyenda se añade la función\n\nlabs(title = título, x = titulo-x, y = titulo-y,\ncolour = leyenda-color, shape  = leyenda-forma)\n\n\n\nlibrary(ggplot2)\ndf <- read.csv('https://raw.githubusercontent.com/asalber/manual-r/master/datos/colesterol.csv')\n# Inicializar el gráfico con la altura en el atributo x y el peso en el atributo y.\nggplot(df, aes(x = altura, y = peso)) +\n# Añadir la capa de puntos.\n    geom_point() +\n# Añadir un título al gráfico y a los ejes.\n    labs(title = \"Diagrama de dispersión\", x = \"Altura (m)\", y = \"Peso (kg)\")\n\n\n\n\n\n\n\n7.12.2 Temas\nFinalmente se para cambiar otros aspectos del gráfico como las fuentes o los colores de fondos se utilizan temas. Para indicar o modificar un tema se añade la función\n\ntheme(propiedades): Modifica las propiedades del tema indicadas. La lista es demasiado grande para cubrirla en este tutorial, por lo que se recomienda ver todas las opciones en la documentación de ggplot2.\n\n\n\nlibrary(ggplot2)\ndf <- read.csv('https://raw.githubusercontent.com/asalber/manual-r/master/datos/colesterol.csv')\n# Inicializar el gráfico con la altura en el atributo x y el peso en el atributo y.\nggplot(df, aes(x = altura, y = peso)) +\n# Añadir la capa de puntos.\n    geom_point() +\n# Añadir un título al gráfico.\n    labs(title = \"Diagrama de dispersión\") +\n# Cambiar el tamaño y el color de la fuente del título.\n    theme(plot.title = element_text(size = 20, colour = \"blue\"))\n\n\n\n\n\n\n\n# Inicializar el gráfico con la altura en el atributo x, el peso en el atributo y, y el sexo al atributo colour.\nggplot(df, aes(x = altura, y = peso, colour = sexo)) +\n# Añadir la capa de puntos.\n    geom_point() +\n# Cambiar el la posición de la leyenda\n    theme(legend.position = \"top\")\n\n\n\n\n\nMás información sobre temas.\nggplot2 incorpora los siguientes temas predefinidos:\n- `theme_gray()`: Tema en escala de grises. Es el tema por defecto.\n- `theme_bw()`: Tema en blanco y negro.\n- `theme_light()`: Tema con las líneas de los ejes y de la rejilla delgadas y atenuadas para dar más protagonismo a los datos.\n- `theme_dark()`: Similar al tema anterior pero con fondo oscuro.\n- `theme_minimal()`: Tema sin fondo.\n- `theme_classic()`: Tema sin rejilla.\n- `theme_void()`: Tema vacío.\n\n\n# Inicializar el gráfico con la altura en el atributo x, el peso en el atributo y, y el sexo al atributo colour.\nggplot(df, aes(x = altura, y = peso, colour = sexo)) +\n# Añadir la capa de puntos.\n    geom_point() +\n# Usar el tema sin rejilla\n    theme_classic()"
  }
]