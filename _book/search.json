[{"path":"index.html","id":"prefacio","chapter":"Prefacio","heading":"Prefacio","text":"","code":""},{"path":"index.html","id":"propósito-de-este-manual","chapter":"Prefacio","heading":"Propósito de este manual","text":"Este manual proporciona una introducción amigable al lenguaje de programación R para aquellas personas interesadas en utilizar este lenguaje para el análisis de datos.El manual empieza con los conceptos básicos del lenguaje de programación R pero enseguida aborda su uso para la visualización y el análisis estadístico de datos, haciendo un recorrido por los test estadísticos más comunes.Lo más interesante de este manual es la multitud de ejemplos que ilustran el uso de las técnicas estadísticas presentadas, así como los problemas propuestos.El manual aborda los fundamentos matemáticos de los análisis estadísticos presentados, aunque si explica brevemente cuándo deben usarse y cuándo , así como las interpretaciones de los resultados obtenidos en los ejemplos. Si alguien está interesado en profundizar en los detalles matemáticos, puede visitar esta página.es un curso de programación en R, sino de uso de sus funciones predefinidas y de los paquetes más habituales para el análisis de datos.Para cualquier comentario o sugerencia sobre este manual escriba al autor (asalber@ceu.es).","code":""},{"path":"index.html","id":"licencia","chapter":"Prefacio","heading":"Licencia","text":"Este trabajo se libera bajo licencia Creative Commons Atribución-CompartirIgual 4.0 (CC -SA 4.0)\nManual básico de análisis de datos con R Alfredo Sánchez Alberca licensed CC -SA 4.0\n","code":""},{"path":"introducción-a-r.html","id":"introducción-a-r","chapter":"Capítulo 1 Introducción a R","heading":"Capítulo 1 Introducción a R","text":"La gran potencia de cómputo alcanzada por los ordenadores ha convertido los mismos en poderosas herramientas al\nservicio de todas aquellas disciplinas que, como la Estadística, requieren manejar un gran volumen de datos.\nActualmente, prácticamente nadie se plantea hacer un estudio estadístico serio sin la ayuda de un buen programa de\nanálisis de datos. es un potente lenguaje de programación que incluye multitud de funciones para la representación y el análisis de\ndatos.\nFue desarrollado por Robert Gentleman y Ross Ihaka en la Universidad de Auckland en Nueva Zelanda, aunque actualmente es mantenido por una enorme comunidad científica en todo el mundo.\nFigura 1.1: Logotipo de R\nLas ventajas de R frente otros programas habituales de análisis de datos, como pueden ser SPSS, SAS o Matlab, son múltiples:Es software libre y por tanto gratuito. Puede descargarse desde la web .Es multiplataforma. Existen versiones para Windows, Macintosh, Linux y otras plataformas.Está avalado y en constante desarrollo por una amplia comunidad científica distribuida por todo el mundo que lo utiliza como estándar para el análisis de datos.Cuenta con multitud de paquetes para todo tipo de análisis estadísticos y representaciones gráficas, desde los más\nhabituales, hasta los más novedosos y sofisticados que incluyen otros programas. Los paquetes están organizados y\ndocumentados en un repositorio CRAN (Comprehensive R Archive Network) desde donde pueden descargarse libremente.Es programable, lo que permite que el usuario pueda crear fácilmente sus propias funciones o paquetes para\nanálisis de datos específicos.\nExisten multitud de libros, manuales y tutoriales libres que permiten su aprendizaje e ilustran el análisis\nestadístico de datos en distintas disciplinas científicas como las Matemáticas, la Física, la Biología, la Psicología, la Medicina, etc.","code":""},{"path":"introducción-a-r.html","id":"entornos-de-desarrollo","chapter":"Capítulo 1 Introducción a R","heading":"1.1 Entornos de desarrollo","text":"Por defecto el entorno de trabajo de R es en línea de comandos, lo que significa que los cálculos y los análisis se realizan mediante comandos o instrucciones que el usuario teclea en una ventana de texto. obstante, existen distintas\ninterfaces gráficas de usuario que facilitan su uso, sobre todo para usuarios noveles. Algunas de ellas, como las que se enumeran continuación, son completos entornos de desarrollo que facilitan la gestión de cualquier proyecto:RStudio. Probablemente el entorno de desarrollo más extendido para programar con R ya que incorpora multitud de utilidades para facilitar la programación con R.RKWard. Es otra otro de los entornos de desarrollo más completos que además incluye posibilidad de añadir nuevos menús y cuadros de diálogo personalizados.Visual Studio Code. Es un entorno de desarrollo de propósito general ampliamente extendido. Aunque es un entorno de desarrollo específico para R, incluye una extensión con utilidades que facilitan mucho el desarrollo con R.","code":""},{"path":"tipos-de-datos-simples.html","id":"tipos-de-datos-simples","chapter":"Capítulo 2 Tipos de datos simples","heading":"Capítulo 2 Tipos de datos simples","text":"En R existen distintos tipos de datos predefinidos simples:numeric: Es el tipo de los números. Secuencia de dígitos (pueden incluir el - para negativos y el punto como separador de decimales) que representan números. Por ejemplo, 1, -2.0, 3.1415 o 4.5e3.\nPor defecto, cualquier número que se teclee tomará este tipo.numeric: Es el tipo de los números. Secuencia de dígitos (pueden incluir el - para negativos y el punto como separador de decimales) que representan números. Por ejemplo, 1, -2.0, 3.1415 o 4.5e3.\nPor defecto, cualquier número que se teclee tomará este tipo.double: Es el tipo de los números reales. Secuencia de dígitos que incluyen decimales separados por punto. Por ejemplo 3.1415 o -2.0. Son una subclase del tipo de datos numérico.double: Es el tipo de los números reales. Secuencia de dígitos que incluyen decimales separados por punto. Por ejemplo 3.1415 o -2.0. Son una subclase del tipo de datos numérico.integer: Es el tipo de los números enteros. Secuencia de dígitos sin separador de decimales que representan un número entero. Por ejemplo 1 o -2. Son una subclase del tipo de datos numérico.integer: Es el tipo de los números enteros. Secuencia de dígitos sin separador de decimales que representan un número entero. Por ejemplo 1 o -2. Son una subclase del tipo de datos numérico.character: Es cualquier cadena de caracteres alfanuméricos. Secuencia de caracteres alfanuméricos que representan texto. Se escriben entre comillas simples o dobles. Por ejemplo \"Hola\" o 'Hola'.character: Es cualquier cadena de caracteres alfanuméricos. Secuencia de caracteres alfanuméricos que representan texto. Se escriben entre comillas simples o dobles. Por ejemplo \"Hola\" o 'Hola'.logical: Es el tipo de los booleanos. Puede tomar cualquiera de los dos valores lógicos TRUE (verdadero) o FALSE (falso). También se pueden abreviar como T o F.logical: Es el tipo de los booleanos. Puede tomar cualquiera de los dos valores lógicos TRUE (verdadero) o FALSE (falso). También se pueden abreviar como T o F.NA: Se utiliza para representar datos desconocidos o perdidos. Aunque en realidad es un dato lógico, puede considerarse con un tipo de dato especial.NA: Se utiliza para representar datos desconocidos o perdidos. Aunque en realidad es un dato lógico, puede considerarse con un tipo de dato especial.NULL: Se utiliza para representar la ausencia de datos. La principal diferencia con NA es que NULL aparece cuando se intenta acceder un dato que existe, mientras que NA se utiliza para representar explícitamente datos perdidos en un estudio.NULL: Se utiliza para representar la ausencia de datos. La principal diferencia con NA es que NULL aparece cuando se intenta acceder un dato que existe, mientras que NA se utiliza para representar explícitamente datos perdidos en un estudio.factor: Es un tipo de dato que solo puede tomar valores de un conjunto predefinido conocido como niveles del factor. Los factores se suelen utilizar para representar datos cualitativos o categóricos. Para definir un factor se utiliza la siguiente función:\nfactor(x, levels=niveles): Crea un dato de tipo factor con el valor x. Los niveles del factor pueden indicarse mediante el parámetro levels, pasándole un vector con los valores posibles.\nfactor: Es un tipo de dato que solo puede tomar valores de un conjunto predefinido conocido como niveles del factor. Los factores se suelen utilizar para representar datos cualitativos o categóricos. Para definir un factor se utiliza la siguiente función:factor(x, levels=niveles): Crea un dato de tipo factor con el valor x. Los niveles del factor pueden indicarse mediante el parámetro levels, pasándole un vector con los valores posibles.Para averiguar el tipo de un dato se puede utilizar la siguiente función:class(x): Devuelve el tipo del dato x.Ejemplo 2.1  continuación se muestran los tipos de algunos datos.También pueden utilizarse las siguientes funciones que devuelven un booleano:.numeric(x): Devuelve el booleano TRUE si x es del tipo numeric..double(x): Devuelve el booleano TRUE si x es del tipo double..integer(x): Devuelve el booleano TRUE si x es del tipo integer..character(x): Devuelve el booleano TRUE si x es del tipo character..logical(x): Devuelve el booleano TRUE si x es del tipo logical..na(x): Devuelve el booleano TRUE si x es del tipo NA..null(x): Devuelve el booleano TRUE si x es del tipo NULL..factor(x): Devuelve el booleano TRUE si x es del tipo factor.","code":"\nclass(3.1415)\n#> [1] \"numeric\"\nclass(-1)\n#> [1] \"numeric\"\nclass(\"Hola\")\n#> [1] \"character\"\nclass(TRUE)\n#> [1] \"logical\"\nclass(NA)\n#> [1] \"logical\"\nclass(NULL)\n#> [1] \"NULL\"\nclass(factor('mujer', levels = c('hombre', 'mujer')))\n#> [1] \"factor\""},{"path":"tipos-de-datos-simples.html","id":"conversión-de-tipos","chapter":"Capítulo 2 Tipos de datos simples","heading":"2.1 Conversión de tipos","text":"En muchas ocasiones es posible convertir un dato de un tipo otro distinto. Para ello se usan las siguientes funciones:.numeric(x): Convierte el dato de x al tipo numeric siempre que sea posible o tenga sentido la conversión. Para convertir una cadena en un número, la cadena tiene que representar un número. El valor lógico TRUE se convierte en 1 y el FALSE en 0..integer(x): Convierte el dato de x al tipo integer siempre que sea posible o tenga sentido la conversión. Para convertir una cadena en un número entero, la cadena tiene que representar un número entero. El valor lógico TRUE se convierte en 1 y el FALSE en 0..character(x): Convierte el tipo de dato de x al tipo character simplemente añadiendo comillas..logical(x): Convierte el tipo de dato de x al tipo lógico. Para datos numéricos, el 0 se convierte en FALSE y cualquier otro número en TRUE. Para cadenas se obtiene NA excepto para las cadenas \"TRUE\" y \"true\" que se convierten TRUE y las cadenas \"FALSE\" y \"false\" que se convierten FALSE.El tipo NA se puede convertir ningún otro tipo pues representa la ausencia del dato. Lo mismo ocurre con NULL.","code":""},{"path":"tipos-de-datos-simples.html","id":"operaciones-con-números","chapter":"Capítulo 2 Tipos de datos simples","heading":"2.2 Operaciones con números","text":"","code":""},{"path":"tipos-de-datos-simples.html","id":"operadores-aritméticos","chapter":"Capítulo 2 Tipos de datos simples","heading":"2.2.1 Operadores aritméticos","text":"Los siguientes operadores permiten realizar las clásicas operaciones aritméticas entre datos numéricos:x + y: Devuelve la suma de x e y.x - y: Devuelve la resta de x e y.x * y: Devuelve el producto de x e y.x / y: Devuelve el cociente de x e y.x %% y: Devuelve el resto de la división entera de x e y.x ^ y: Devuelve la potencia x elevado y.Ejemplo 2.2  continuación se muestran varios ejemplos de operaciones aritméticas.","code":"\n2 + 3\n#> [1] 5\n5 * -2\n#> [1] -10\n5 / 2\n#> [1] 2.5\n5 %% 2\n#> [1] 1\n2 ^ 3\n#> [1] 8"},{"path":"tipos-de-datos-simples.html","id":"operadores-relacionales","chapter":"Capítulo 2 Tipos de datos simples","heading":"2.2.2 Operadores relacionales","text":"Comparan dos números y devuelven un valor lógico.x == y : Devuelve TRUE si el número x es igual que el número y, y FALSE en caso contrario.x > y : Devuelve TRUE si el número x es mayor que el número y, y FALSE en caso contrario.x < y : Devuelve TRUE si el número x es menor que el número y, y FALSE en caso contrario.x >= y : Devuelve TRUE si el número x es mayor o igual que el número y, y FALSE en caso contrario.x <= y : Devuelve TRUE si el número x es menor o igual que el número y, y FALSE en caso contrario.x != y : Devuelve TRUE si el número x es distinto del número y, y FALSE en caso contrario.Ejemplo 2.3  continuación se muestran varios ejemplos de operaciones relacionales.","code":"\n3 == 3\n#> [1] TRUE\n3.1 <= 3\n#> [1] FALSE\n4 > 3\n#> [1] TRUE\n-1 != 1\n#> [1] TRUE\n5 %% 2\n#> [1] 1\n2 ^ 3\n#> [1] 8\n(2 + 3) ^ 2\n#> [1] 25"},{"path":"tipos-de-datos-simples.html","id":"operaciones-con-cadenas","chapter":"Capítulo 2 Tipos de datos simples","heading":"2.3 Operaciones con cadenas","text":"","code":""},{"path":"tipos-de-datos-simples.html","id":"funciones-de-cadenas","chapter":"Capítulo 2 Tipos de datos simples","heading":"2.3.1 Funciones de cadenas","text":"Existen muchas funciones para cadenas de texto pero las más comunes son:nchar(c): Devuelve un número entero con el número de caracteres de la cadena.paste(x, y, ..., sep=s): Concatena las cadenas x, y, etc. separándolas por la cadena s. Por defecto la cadena de separación es un espacio en blanco.substr(c, start=, stop=j): Devuelve la subcadena de la cadena c desde la posición hasta la posición j. El primer carácter de una cadena ocupa la posición 1.tolower(c): Devuelve la cadena que resulta de convertir la cadena c minúsculas.toupper(c): Devuelve la cadena que resulta de convertir la cadena c mayúsculas.Ejemplo 2.4  continuación se muestran varios ejemplos de operaciones con cadenas de texto.","code":"\nnchar(\"Me gusta R\")\n#> [1] 10\npaste(\"Me\", \"gusta\", \"R\")\n#> [1] \"Me gusta R\"\npaste(\"Me\", \"gusta\", \"R\", sep = \"-\")\n#> [1] \"Me-gusta-R\"\npaste(\"Me\", \"gusta\", \"R\", sep = \"\")\n#> [1] \"MegustaR\"\nsubstr(\"Me gusta R\", 4, 8)\n#> [1] \"gusta\"\ntolower(\"Me gusta R\")\n#> [1] \"me gusta r\"\ntoupper(\"Me gusta R\")\n#> [1] \"ME GUSTA R\""},{"path":"tipos-de-datos-simples.html","id":"operaciones-de-comparación-de-cadenas","chapter":"Capítulo 2 Tipos de datos simples","heading":"2.3.2 Operaciones de comparación de cadenas","text":"x == y : Devuelve TRUE si la cadena x es igual que la cadena y, y FALSE en caso contrario.x > y : Devuelve TRUE si la cadena x sucede la cadena y, y FALSE en caso contrario.x < y : Devuelve TRUE si la cadena x antecede la cadena y, y FALSE en caso contrario.x >= y : Devuelve TRUE si la cadena x sucede o es igual la cadena y, y FALSE en caso contrario.x <= y : Devuelve TRUE si la cadena x antecede o es igual la cadena y, y FALSE en caso contrario.x != y : Devuelve TRUE si la cadena x es distinta de la cadena y, y FALSE en caso contrario. Utilizan el orden alfabético, las minúsculas van antes que las mayúsculas, y los números antes que las letras.Ejemplo 2.5  continuación se muestran varios ejemplos de operaciones de comparación de cadenas.","code":"\n\"R\" == \"R\"\n#> [1] TRUE\n\"R\" == \"r\"\n#> [1] FALSE\n\"uno\" < \"dos\"\n#> [1] FALSE\n\"A\" > \"a\"\n#> [1] TRUE\n\"\" < \"R\"\n#> [1] TRUE"},{"path":"tipos-de-datos-simples.html","id":"operaciones-con-datos-lógicos-o-booleanos","chapter":"Capítulo 2 Tipos de datos simples","heading":"2.4 Operaciones con datos lógicos o booleanos","text":"","code":""},{"path":"tipos-de-datos-simples.html","id":"operadores-lógicos","chapter":"Capítulo 2 Tipos de datos simples","heading":"2.4.1 Operadores lógicos","text":"la hora de comparar valores lógicos R asocia TRUE el valor 1 y FALSE el valor 0.x == y: Devuelve TRUE si los booleanos x y y son iguales, y FALSE en caso contrario.x < y: Devuelve TRUE si el booleano x es menor que el booleano y, y FALSE en caso contrario.x <= y: Devuelve TRUE si el booleano x es menor o igual que el booleano y, y FALSE en caso contrario.x > y: Devuelve TRUE si el booleano x es mayor que el booleano y, y FALSE en caso contrario.x >= y: Devuelve TRUE si el booleano x es mayor o igual que el booleano y, y FALSE en caso contrario.x != y: Devuelve TRUE si el booleano x es distinto que el booleano y, y FALSE en caso contrario.Negación !b: Devuelve TRUE si el booleano b es FALSE, y FALSE si es TRUE.Conjunción x & y: Devuelve TRUE si los booleanos x, y y son TRUE y FALSE en caso contrario.Disyunción x | y: Devuelve TRUE si alguno de los booleanos x o y son TRUE, y FALSE en caso contrario.","code":""},{"path":"tipos-de-datos-simples.html","id":"tabla-de-verdad","chapter":"Capítulo 2 Tipos de datos simples","heading":"Tabla de verdad","text":"Ejemplo 2.6  continuación se muestran varios ejemplos de operaciones lógicas con booleanos.","code":"\n!TRUE\n#> [1] FALSE\nFALSE | TRUE\n#> [1] TRUE\nFALSE | FALSE\n#> [1] FALSE\nTRUE & FALSE\n#> [1] FALSE\nTRUE & TRUE\n#> [1] TRUE"},{"path":"tipos-de-datos-simples.html","id":"variables","chapter":"Capítulo 2 Tipos de datos simples","heading":"2.5 Variables","text":"Una variable es un identificador ligado algún valor.Reglas para nombrarlas:Comienzan siempre por una letra o punto, seguida de otras letras, números, puntos o guiones bajos. Si empieza por punto puede seguirle un número.se pueden utilizarse palabras reservadas del lenguaje.diferencia de otros lenguajes de programación, las variables tienen asociado un tipo y es necesario declararlas antes de usarlas (tipado dinámico).Para asignar un valor una variable se utiliza el operador de asignación <-:x <- y: Asigna el valor y la variable x.Aunque es menos común también se puede utilizar el operador =.Se puede crear una variable sin ningún valor asociado asignándole el valor NULL.Una vez definida una variable, puede utilizarse en cualquier expresión donde tenga sentido el valor que tiene asociado.Si una variable ya va usarse, es posible eliminarla y liberar el espacio que ocupan sus datos asociados con la siguiente función:rm(x): Elimina la variable x.Ejemplo 2.7  continuación se muestran varios ejemplos de asignaciones de valores variables.","code":"\nx <- 3\nx\n#> [1] 3\ny <- x + 2\ny\n#> [1] 5\n# Valor no definido\nx <- NULL\nx\n#> NULL\n# Eliminar y\nrm(y)\n# A partir de aquí, una llamada a y produce un error."},{"path":"tipos-de-datos-simples.html","id":"prioridad-de-los-operadores","chapter":"Capítulo 2 Tipos de datos simples","heading":"2.5.1 Prioridad de los operadores","text":"Al evaluar una expresiones R utiliza el siguiente orden de prioridad de evaluación:Se puede saltar el orden de evaluación utilizando paréntesis ( ).Ejemplo 2.8  continuación se muestran varios ejemplos de evaluación de expresiones.Ejercicio 2.1  Se dispone de los siguientes datos de una persona:Declarar las variables anteriores y asignarles los valores correspondientes.Declarar las variables anteriores y asignarles los valores correspondientes.Definir la variable numérica imc con el índice de masa corporal aplicando la siguiente fórmula las variables anteriores:Definir la variable numérica imc con el índice de masa corporal aplicando la siguiente fórmula las variables anteriores:\\[\\mbox{imc} = \\frac{\\mbox{peso (kg)}}{\\mbox{estatura (m)}^2}\\]Definir la variable booleana obesa con el valor correspondiente la siguiente condición: ser mujer y tener una edad superior 60 y tener un índice de masa corporal mayor o igual que 30. ¿Es esta persona obesa?Solución. Solución el ejercicio.","code":"\n4 + 8 / 2 ^ 2\n#> [1] 6\n4 + (8 / 2) ^ 2\n#> [1] 20\n(4 + 8) / 2 ^ 2\n#> [1] 3\n(4 + 8 / 2) ^ 2\n#> [1] 64\nx <- 2 \ny <- 3\nz <- ! x + 1 > y & y * 2  < x ^ 3\nz\n#> [1] TRUE\n# Declaración de variables\nedad <- 20\nestatura <- 165\npeso <- 60\nsexo <- \"mujer\"\n# Cálculo del índice de masa corporal\nimc <- peso / (estatura / 100) ^ 2\nimc\n#> [1] 22.03857\n# Cálculo de la obesidad\nobesa <- sexo == \"mujer\" & ! edad > 60 & imc >= 30\nobesa\n#> [1] FALSE"},{"path":"tipos-de-datos-simples.html","id":"section","chapter":"Capítulo 2 Tipos de datos simples","heading":"2.6 ","text":"","code":""},{"path":"tipos-de-datos-estructurados.html","id":"tipos-de-datos-estructurados","chapter":"Capítulo 3 Tipos de datos estructurados","heading":"Capítulo 3 Tipos de datos estructurados","text":"Los tipos estructurados de datos, diferencia de los simples, son colecciones de datos con una determinada estructura. En R existen varios tipos tipos estructurados de datos que pueden clasificarse de acuerdo su dimensión y si son homogéneos (todos sus elementos son del mismo tipo) o heterogéneos.Para averiguar la estructura de un dato estructurado se puede utilizar la función siguiente:str(x): Devuelve una cadena de texto con la estructura de x en un formato amigable para los humanos.","code":""},{"path":"tipos-de-datos-estructurados.html","id":"vectores","chapter":"Capítulo 3 Tipos de datos estructurados","heading":"3.1 Vectores","text":"El vector es el tipo de dato estructurado más básicos en R. Un vector es una colección ordenada de elementos del mismo tipo.","code":""},{"path":"tipos-de-datos-estructurados.html","id":"creación-de-vectores","chapter":"Capítulo 3 Tipos de datos estructurados","heading":"3.1.1 Creación de vectores","text":"Para construir un vector se utiliza la función de combinación c():c(x1, x2, ...): Devuelve el vector formado por los elementos x1, x2, etc.También es posible utilizar el operador : para generar un vector de números enteros consecutivos:x:y: Devuelve el vector de números enteros consecutivos desde x hasta y.Ejemplo 3.1  continuación se muestran varios ejemplos de construcción de vectores.","code":"\nc(1, 2, 3)\n#> [1] 1 2 3\nc(\"uno\", \"dos\", \"tres\")\n#> [1] \"uno\"  \"dos\"  \"tres\"\n# Vector vacío\nc()\n#> NULL\n# Vector con elementos perdidos\nc(1, NA, 3)\n#> [1]  1 NA  3\n# Vector de números enteros consecutivos del 2 al 6\n2:6\n#> [1] 2 3 4 5 6"},{"path":"tipos-de-datos-estructurados.html","id":"vectores-con-nombres","chapter":"Capítulo 3 Tipos de datos estructurados","heading":"3.1.1.1 Vectores con nombres","text":"Es posible asignar un nombre cada elemento de un vector. Los nombres son etiquetas de texto que se asocian cada elemento. Para asociar un nombre un elemento se utiliza la sintaxis nombre = valor, donde nombre es una cadena de caracteres y valor es el elemento del vector.Ejemplo 3.2  continuación se muestra un ejemplo de creación de un vector con nombres.Para acceder los nombres de un vector se utiliza la siguiente función:names(x): Devuelve un vector de cadenas de caracteres con los nombres de los elementos del vector x.Ejemplo 3.3  continuación se muestra un ejemplo de acceso los nombres de un vector.","code":"\nc(\"Matemáticas\" = 8.2, \"Física\" = 6.5, \"Economía\" = 4.5)\n#> Matemáticas      Física    Economía \n#>         8.2         6.5         4.5\nnotas <- c(\"Matemáticas\" = 8.2, \"Física\" = 6.5, \"Economía\" = 4.5)\nnames(notas)\n#> [1] \"Matemáticas\" \"Física\"      \"Economía\""},{"path":"tipos-de-datos-estructurados.html","id":"tamaño-de-un-vector","chapter":"Capítulo 3 Tipos de datos estructurados","heading":"3.1.2 Tamaño de un vector","text":"El número de elementos de un vector es su tamaño y puede averiguarse con la siguiente función.lenght(x): Devuelve el número de elementos del vector x.Ejemplo 3.4  continuación se muestran varios ejemplos de la obtención del tamaño de un vector.","code":"\nlength(c(1, 2, 3))\n#> [1] 3\nlength(c())\n#> [1] 0"},{"path":"tipos-de-datos-estructurados.html","id":"coerción-de-elementos","chapter":"Capítulo 3 Tipos de datos estructurados","heading":"3.1.3 Coerción de elementos","text":"Puesto que los elementos de un vector tienen que ser del mismo tipo, cuando se crea un vector con datos de distintos tipos, la función c() los convertirá al mismo tipo, lo que se conoce como coerción de tipos. La coerción se produce de los tipos menos flexibles los más flexibles: logical < integer < double < character.Ejemplo 3.5  continuación se muestran varios ejemplos de coerciones.","code":"\nc(1, 2.5)\n#> [1] 1.0 2.5\nc(FALSE, TRUE, 2)\n#> [1] 0 1 2\nc(FALSE, TRUE, 2, \"tres\")\n#> [1] \"FALSE\" \"TRUE\"  \"2\"     \"tres\""},{"path":"tipos-de-datos-estructurados.html","id":"acceso-a-los-elementos-de-un-vector","chapter":"Capítulo 3 Tipos de datos estructurados","heading":"3.1.4 Acceso a los elementos de un vector","text":"Para acceder los elementos de un vector se utiliza un índice. Como veremos continuación, este índice puede ser entero, lógico o de cadena de caracteres y se indica siempre entre corchetes [ ] continuación del vector.","code":""},{"path":"tipos-de-datos-estructurados.html","id":"acceso-mediante-un-índice-entero","chapter":"Capítulo 3 Tipos de datos estructurados","heading":"3.1.4.1 Acceso mediante un índice entero","text":"Los elementos de un vector están ordenados y el acceso más simple ellos es mediante su número de orden, es decir, indicando entre corchetes el entero que corresponde su número de orden. Se puede acceder simultáneamente varios elementos mediante un vector con sus números de orden. Por otro lado, también es posible usar enteros negativos y en tal caso se obtendrán todos los elementos del vector excepto los que ocupan las posiciones correspondientes al valor absoluto de los índices negativos. Esta es la forma más habitual de eliminar elementos de un vector. En R los índices enteros para acceder los elementos de un vector comienzan en 1, diferencia de otros lenguajes de programación que empiezan en 0.Ejemplo 3.6  continuación se muestran varios ejemplos de acceso los elementos de un vector mediante índices enteros.","code":"\nx <- c(2,4,6,8,10)\n# Acceso al elemento que está en la tercera posición\nx[3]\n#> [1] 6\n# Acceso a los elementos de las posiciones 2 y 4\nx[c(2, 4)]\n#> [1] 4 8\n# Acceso a todos los elementos excepto el primero y el quinto\nx[c(-1, -5)]\n#> [1] 4 6 8"},{"path":"tipos-de-datos-estructurados.html","id":"acceso-mediante-un-índice-lógico","chapter":"Capítulo 3 Tipos de datos estructurados","heading":"3.1.4.2 Acceso mediante un índice lógico","text":"Cuando se utiliza un índice lógico, se obtienen los elementos correspondientes las posiciones donde está el valor booleano TRUE.Ejemplo 3.7  continuación se muestran varios ejemplos de acceso los elementos de un vector mediante índices lógicos.Esta forma de acceder es útil cuando se genera el vector de índices mediante operadores relacionales. Cuando se aplica un operador relacional un vector se obtiene otro vector lógico que resulta de aplicar el operador relacional cada uno de los elementos del vector. De esta manera se puede realizar filtros para obtener los elementos de un vector que cumplen una determinada condición.Ejemplo 3.8  continuación se muestran varios ejemplos de acceso los elementos de un vector mediante condiciones.","code":"\nx <- c(2,4,6,8,10)\n# Acceso al elemento que está en la tercera posición\nx[c(F,F,T,F,F)]\n#> [1] 6\n# Acceso a los elementos de las posiciones 2 y 4\nx[c(F,T,F,T,F)]\n#> [1] 4 8\nx <- 1:6\nx %% 2 == 0\n#> [1] FALSE  TRUE FALSE  TRUE FALSE  TRUE\n# Filtrado de los valores pares\nx[x %% 2 == 0]\n#> [1] 2 4 6\n# Filtrado de los valores pares menores que 5\nx[x %% 2 == 0 & x < 5]\n#> [1] 2 4"},{"path":"tipos-de-datos-estructurados.html","id":"acceso-mediante-un-índice-de-cadena","chapter":"Capítulo 3 Tipos de datos estructurados","heading":"3.1.4.3 Acceso mediante un índice de cadena","text":"Si los elementos de un vector tienen nombre, es posible acceder ellos usando sus nombres como índices.Ejemplo 3.9  continuación se muestran varios ejemplos de acceso los elementos de un vector mediante índices de cadena.","code":"\nnotas <- c(\"Matemáticas\" = 8.2, \"Física\" = 6.5, \"Economía\" = 4.5)\nnotas[\"Física\"]\n#> Física \n#>    6.5\nnotas[c(\"Matemáticas\", \"Economía\")]\n#> Matemáticas    Economía \n#>         8.2         4.5"},{"path":"tipos-de-datos-estructurados.html","id":"pertenencia-a-un-vector","chapter":"Capítulo 3 Tipos de datos estructurados","heading":"3.1.5 Pertenencia a un vector","text":"Para comprobar si un valor en particular es un elemento de un vector se puede utilizar el operador %%:x %% y: Devuelve el booleano TRUE si x es un elemento del vector y, y FALSE en caso contrario.Ejemplo 3.10  continuación se muestran varios ejemplos de pertenencia de elementos un vector.Para modificar uno o varios elementos de un vector basta con acceder esos elementos y usar el operador de asignación para asignar nuevos valores.Ejemplo 3.11  continuación se muestran varios ejemplos de modificación de los elementos de un vector.Para añadir nuevos elementos un vector pueden usarse las siguientes funciones:c(x, y): Devuelve el vector que resulta de añadir al vector x los elementos del vector y.append(x, y, pos): Devuelve el vector que resulta de añadir al vector x los elementos del vector y, continuación de la posición pos. El parámetro pos es opcional y si se indica, los elementos de y se añaden al final de los de x.Ejemplo 3.12  continuación se muestran varios ejemplos de añadir nuevos elementos un vector.Para eliminar los elementos de un vector basta con asignar NULL la variable que lo contiene, pero si se quiere liberar la memoria que ocupa la variable se utiliza la función rm().Las listas son colecciones ordenadas de elementos de que pueden ser de distintos tipos. Los elementos de una lista también pueden ser de tipos estructurados (vectores o listas), lo que las convierte en el tipo de dato más versátil de R. Como veremos más adelante, otras estructuras de datos como los data frames o los propios modelos estadísticos se construyen usando listas.Para construir una lista se utiliza la función list():list(x1, x2, ...): Devuelve la lista con los elementos x1, x2, etc.Ejemplo 3.13  continuación se muestran varios ejemplos de creación de listas.Ejemplo 3.14  continuación se muestra un ejemplo de creación de una lista con nombres.Para obtener los nombres de una lista se utiliza la siguiente función:names(x): Devuelve un vector de cadenas de caracteres con los nombres de los elementos de la lista x.Ejemplo 3.15  continuación se muestra un ejemplo de acceso los nombres de una lista.El número de elementos de una lista es su tamaño y puede averiguarse con la siguiente función:lenght(x): Devuelve el número de elementos de la lista x.Ejemplo 3.16  continuación se muestran varios ejemplos la obtención del tamaño de una lista.Se accede los elementos de una lista de forma similar los vectores, mediante índices enteros, lógicos o de cadena, entre corchetes [ ].Al igual que los vectores, los elementos de una lista están ordenados y se puede utilizar un índice entero para acceder los elementos que ocupan una determinada posición.Ejemplo 3.17  continuación se muestran varios ejemplos de acceso los elementos de una lista mediante índices enteros.Cuando se utiliza un índice lógico, se obtienen los elementos correspondientes las posiciones donde está el valor booleano TRUE.Ejemplo 3.18  continuación se muestran varios ejemplos de acceso los elementos de una lista mediante índices lógicos.Obsérvese que para los elementos que tiene sentido la comparación se obtiene NA, y que el acceso mediante este índice devuelve NULL.Si los elementos de una lista tienen nombre, se puede acceder ellos utilizando sus nombres como índices. La única diferencia con el acceso mediante cadenas de vectores es que se obtiene siempre una lista, incluso cuando sólo se quiere acceder un elemento. Para obtener un elemento, y una lista con ese único elemento, se utilizan dobles corchetes [[ ]].Ejemplo 3.19  continuación se muestran varios ejemplos de acceso los elementos de una lista mediante índices de cadena.Una alternativa los dobles corchetes es el operador de acceso listas $. Este operador además permite utilizar coincidencias parciales en los nombres de los elementos para acceder ellos.Ejemplo 3.20  continuación se muestran varios ejemplos de acceso los elementos de una lista mediante el operador $.Para modificar uno o varios elementos de una lista basta con acceder esos elementos y reasignarles valors con el operador de asignación.Ejemplo 3.21  continuación se muestran varios ejemplos de modificación de los elementos de una lista.La forma más sencilla de añadir un elemento con nombre una lista es indicando el nombre con el operador $ y asignándole un valor con el operador de asignación <-:x$nombre <- y: Añade el elemento y la lista x con el nombre nombre.El nuevo elemento se añade siempre al final de la lista.Para añadir elementos sin nombre o en una posición determinada se puede utilizar la función append():append(x, y, pos): Devuelve la lista vector que resulta de añadir x los elementos de la lista y, continuación de la posición pos. El parámetro pos es opcional y si se indica, los elementos de y se añaden al final de los de x.Ejemplo 3.22  continuación se muestran varios ejemplos de añadir nuevos elementos una lista.Es posible convertir una lista en un vector con la siguiente función:unlist(x): Devuelve el vector que resulta de aplanar recursivamente la lista x y convertir todos los elementos al mismo tipo mediante coerción de tipos.Ejemplo 3.23  continuación se muestran varios ejemplos de conversión de una lista en un vector.Una matriz es una estructura de datos bidimensional de elementos del mismo tipo organizados en filas y columnas. Una matriz es similar un vector pero contiene una atributo adicional con sus dimensiones (número de filas y número de columnas).Para crear una matriz se utiliza la siguiente función:matrix(x, nrow = m, ncol = n): Devuelve la matriz con los elementos del vector x organizados en n filas y m columnas. Habitualmente basta con especificar el número de filas o el número de columnas.Ejemplo 3.24  continuación se muestran varios ejemplos de creación de matrices.Como se puede observar en el ejemplo anterior, los elementos se disponen por columnas, pero se pueden disponer los elementos por filas pasando el parámetro byrow = TRUE la función matrix.Ejemplo 3.25  continuación se muestran varios ejemplos de creación de matrices.Es posible poner nombres las filas y las columnas de una matriz añadiendo el parámetro dimnames y pasándole una lista de dos vectores de cadenas con los nombres de las filas y las columnas respectivamente.Ejemplo 3.26  continuación se muestran varios ejemplos de creación de matrices con nombres de filas y columnas.Para obtener los nombres de las filas y las columnas de una matriz se utilizan las siguientes funciones:rownames(x): Devuelve un vector de cadenas de caracteres con los nombres de las filas de la matriz x.colnames(x): Devuelve un vector de cadenas de caracteres con los nombres de las columnas de la matriz x.Ejemplo 3.27  continuación se muestran varios ejemplos de creación de matrices con nombres de filas y columnas.Para obtener el número de elementos y las dimensiones de una matriz se pueden utilizar las siguientes funciones:length(x): Devuelve un entero con el número de elementos de la matriz x.nrow(x): Devuelve un entero con el número de filas de la matriz x.ncol(x): Devuelve un entero con el número de columnas de la matriz x.dim(x): Devuelve un vector de dos enteros con el número de filas y el número de columnas de la matriz x.Ejemplo 3.28  continuación se muestran varios ejemplos de acceso las dimensiones de una matriz.Usando esta última función se pueden modificar las dimensiones de una matriz asignando un vector de dos enteros con las nuevas dimensiones. Esto también permite crear una matriz partir de un vector.Ejemplo 3.29  continuación se muestran varios ejemplos de modificación de las dimensiones de una matriz.Para acceder los elementos de una matriz se utilizan dos índices (uno para las filas y otro para las columnas), separados por comas y entre corchetes [] continuación de la matriz. Al igual que para los vectores, los índices pueden ser enteros, lógicos o de cadenas de caracteres.Para acceder los elementos de una matriz mediante índices enteros se indica el número de fila y el número de columna del elemento entre corchetes:x[,j]: Devuelve el elemento de la matriz x que está en la fila y la columna j.Se puede acceder más de un elemento indicando un vector de enteros para las filas y otro para las columnas. De esta manera se obtiene una submatriz. Si se indica la fila o la columna se obtienen todos los elementos de todas las filas o columnas. Al igual que para vectores, se pueden utilizar enteros negativos para descartar filas o columnasEjemplo 3.30  continuación se muestran varios ejemplos de acceso los elementos de una matriz.Cuando se utilizan índices lógicos, se obtienen los elementos correspondientes las filas y columnas donde está el valor booleano TRUE.Ejemplo 3.31  continuación se muestran varios ejemplos de acceso los elementos de una matriz.Si las filas y las columnas de una matriz tienen nombre, es posible acceder sus elementos usando los nombres de las filas y columnas como índices.Finalmente, es posible combinar distintos tipos de índices (enteros, lógicos o de cadena) para indicar las filas y las columnas las que acceder.","code":"\nx <- 1:3\n2 %in% x\n#> [1] TRUE\n4 %in% x\n#> [1] FALSE\nx <- c(1, 2, 3)\nx[2] <- 0\nx\n#> [1] 1 0 3\nx[c(1, 3)] <- 1\nx\n#> [1] 1 0 1\nx <- c(1, 2, 3)\ny <- c(x, c(4, 5))\ny\n#> [1] 1 2 3 4 5\ny <- append(x, c(4, 5), 2)\ny\n#> [1] 1 2 4 5 3\nlist(1, \"dos\", TRUE)\n#> [[1]]\n#> [1] 1\n#> \n#> [[2]]\n#> [1] \"dos\"\n#> \n#> [[3]]\n#> [1] TRUE\n# Lista con vectores y listas\nx <- list(1, c(\"dos\", \"tres\"), list(4, \"cinco\"))\nx\n#> [[1]]\n#> [1] 1\n#> \n#> [[2]]\n#> [1] \"dos\"  \"tres\"\n#> \n#> [[3]]\n#> [[3]][[1]]\n#> [1] 4\n#> \n#> [[3]][[2]]\n#> [1] \"cinco\"\nstr(x)\n#> List of 3\n#>  $ : num 1\n#>  $ : chr [1:2] \"dos\" \"tres\"\n#>  $ :List of 2\n#>   ..$ : num 4\n#>   ..$ : chr \"cinco\"\n# Lista vacía\nlist()\n#> list()\nlist(\"nombre\" = \"María\", \"edad\" = 21, \"dirección\" = list(\"calle\" = \"Delicias\", \"número\" = 24, \"municipio\" = \"Madrid\"))\n#> $nombre\n#> [1] \"María\"\n#> \n#> $edad\n#> [1] 21\n#> \n#> $dirección\n#> $dirección$calle\n#> [1] \"Delicias\"\n#> \n#> $dirección$número\n#> [1] 24\n#> \n#> $dirección$municipio\n#> [1] \"Madrid\"\npersona <- list(\"nombre\" = \"María\", \"edad\" = 21, \"dirección\" = list(\"calle\" = \"Delicias\", \"número\" = 24, \"municipio\" = \"Madrid\"))\nnames(persona)\n#> [1] \"nombre\"    \"edad\"      \"dirección\"\nlength(list(1, \"dos\", TRUE))\n#> [1] 3\nlength(list(1, c(\"dos\", \"tres\"), list(4, \"cinco\")))\n#> [1] 3\nlength(list())\n#> [1] 0\nx <- list(1, \"dos\", TRUE, 4.5)\n# Acceso al elemento que está en la segunda posición\nx[2]\n#> [[1]]\n#> [1] \"dos\"\n# Acceso a los elementos de las posiciones 1 y 3\nx[c(1, 3)]\n#> [[1]]\n#> [1] 1\n#> \n#> [[2]]\n#> [1] TRUE\n# Acceso a todos los elementos excepto el primero y el cuarto\nx[c(-1, -4)]\n#> [[1]]\n#> [1] \"dos\"\n#> \n#> [[2]]\n#> [1] TRUE\nx <- list(1, \"dos\", TRUE, 4.5)\nx[c(T,F,F,T)]\n#> [[1]]\n#> [1] 1\n#> \n#> [[2]]\n#> [1] 4.5\nx < 2\n#> Warning: NAs introducidos por coerción\n#> [1]  TRUE    NA  TRUE FALSE\n# Filtrado de valores menores que 2\nx[x < 2]\n#> Warning: NAs introducidos por coerción\n#> [[1]]\n#> [1] 1\n#> \n#> [[2]]\n#> NULL\n#> \n#> [[3]]\n#> [1] TRUE\npersona <- list(\"nombre\" = \"María\", \"edad\" = 21, \"dirección\" = list(\"calle\" = \"Delicias\", \"número\" = 24, \"municipio\" = \"Madrid\"))\npersona[c(\"edad\", \"nombre\")]\n#> $edad\n#> [1] 21\n#> \n#> $nombre\n#> [1] \"María\"\npersona[\"nombre\"]\n#> $nombre\n#> [1] \"María\"\ntypeof(persona[\"nombre\"])\n#> [1] \"list\"\n# Acceso a un único elemento\npersona[[\"nombre\"]]\n#> [1] \"María\"\n# Acceso a una lista anidada\npersona[[\"dirección\"]][[\"municipio\"]]\n#> [1] \"Madrid\"\npersona <- list(\"nombre\" = \"María\", \"edad\" = 21, \"dirección\" = list(\"calle\" = \"Delicias\", \"número\" = 24, \"municipio\" = \"Madrid\"))\n# Acceso a un único elemento\npersona$nombre\n#> [1] \"María\"\n# Acceso mediante coincidencia parcial\npersona$nom\n#> [1] \"María\"\n# Acceso a una lista anidada\npersona$dirección$municipio\n#> [1] \"Madrid\"\npersona <- list(\"nombre\" = \"María\", \"edad\" = 21)\npersona$edad <- 22\npersona\n#> $nombre\n#> [1] \"María\"\n#> \n#> $edad\n#> [1] 22\npersona <- list(\"nombre\" = \"María\", \"edad\" = 21)\npersona$email <- \"maria@ceu.es\"\npersona\n#> $nombre\n#> [1] \"María\"\n#> \n#> $edad\n#> [1] 21\n#> \n#> $email\n#> [1] \"maria@ceu.es\"\nappend(persona, list(\"sexo\" = \"Mujer\"), 2)\n#> $nombre\n#> [1] \"María\"\n#> \n#> $edad\n#> [1] 21\n#> \n#> $sexo\n#> [1] \"Mujer\"\n#> \n#> $email\n#> [1] \"maria@ceu.es\"\npersona <- list(\"nombre\" = \"María\", \"edad\" = 21, \"dirección\" = list(\"calle\" = \"Delicias\", \"número\" = 24, \"municipio\" = \"Madrid\"))\nunlist(persona)\n#>              nombre                edad     dirección.calle \n#>             \"María\"                \"21\"          \"Delicias\" \n#>    dirección.número dirección.municipio \n#>                \"24\"            \"Madrid\"\ntypeof(unlist(persona))\n#> [1] \"character\"\nmatrix(1:6, nrow = 2, ncol = 3)\n#>      [,1] [,2] [,3]\n#> [1,]    1    3    5\n#> [2,]    2    4    6\nmatrix(1:6, nrow = 2)\n#>      [,1] [,2] [,3]\n#> [1,]    1    3    5\n#> [2,]    2    4    6\nmatrix(1:6, ncol = 3)\n#>      [,1] [,2] [,3]\n#> [1,]    1    3    5\n#> [2,]    2    4    6\n# La matriz de 1 x 1 \nmatrix()\n#>      [,1]\n#> [1,]   NA\nmatrix(1:6, nrow = 2)\n#>      [,1] [,2] [,3]\n#> [1,]    1    3    5\n#> [2,]    2    4    6\nmatrix(1:6, nrow = 2, byrow = TRUE)\n#>      [,1] [,2] [,3]\n#> [1,]    1    2    3\n#> [2,]    4    5    6\nmatrix(1:6, nrow = 2, ncol = 3, dimnames = list(c(\"fila1\", \"fila2\"), c(\"columna1\", \"columna2\", \"columna3\")))\n#>       columna1 columna2 columna3\n#> fila1        1        3        5\n#> fila2        2        4        6\nx <- matrix(1:6, nrow = 2, ncol = 3, dimnames = list(c(\"fila1\", \"fila2\"), c(\"columna1\", \"columna2\", \"columna3\")))\nrownames(x)\n#> [1] \"fila1\" \"fila2\"\ncolnames(x)\n#> [1] \"columna1\" \"columna2\" \"columna3\"\nx <- matrix(1:6, nrow = 2)\nlength(x)\n#> [1] 6\nnrow(x)\n#> [1] 2\nncol(x)\n#> [1] 3\ndim(x)\n#> [1] 2 3\nx <- 1:6\ndim(x) <- c(2, 3)\nx\n#>      [,1] [,2] [,3]\n#> [1,]    1    3    5\n#> [2,]    2    4    6\ndim(x) <- c(3, 2)\nx\n#>      [,1] [,2]\n#> [1,]    1    4\n#> [2,]    2    5\n#> [3,]    3    6\nx <- matrix(1:9, nrow = 3)\nx\n#>      [,1] [,2] [,3]\n#> [1,]    1    4    7\n#> [2,]    2    5    8\n#> [3,]    3    6    9\n# Acceso al elemento de la segunda fila y tercera columna\nx[2,3]\n#> [1] 8\n# Acceso a la submatriz de la primera y tercera filas, y tercera y segunda columnas\nx[c(1, 3), c(3, 2)]\n#>      [,1] [,2]\n#> [1,]    7    4\n#> [2,]    9    6\n# Acceso a la primera fila\nx[1, ]\n#> [1] 1 4 7\n# Acceso a la segunda columna\nx[, 2]\n#> [1] 4 5 6\n# Acceso a la submatriz con todos los elementos salvo la tercera fila y la segunda columna\nx[-3, -2]\n#>      [,1] [,2]\n#> [1,]    1    7\n#> [2,]    2    8\nx <- matrix(1:9, nrow = 3)\nx\n#>      [,1] [,2] [,3]\n#> [1,]    1    4    7\n#> [2,]    2    5    8\n#> [3,]    3    6    9\n# Acceso al elemento de la segunda fila y tercera columna\nx[c(F, T, F), c(F, F, T)]\n#> [1] 8\n# Acceso a la submatriz de la primera y tercera filas, y segunda y tercera columnas\nx[c(T, F, T), c(F, T, T)]\n#>      [,1] [,2]\n#> [1,]    4    7\n#> [2,]    6    9\n# Acceso a la primera fila\nx[c(T, F, F), ]\n#> [1] 1 4 7\n# Acceso a la segunda columna\nx[, c(F, T, F)]\n#> [1] 4 5 6\nx <- matrix(1:9, nrow = 3, dimnames = list(c(\"f1\", \"f2\", \"f3\"), c(\"c1\", \"c2\", \"c3\")))\nx\n#>    c1 c2 c3\n#> f1  1  4  7\n#> f2  2  5  8\n#> f3  3  6  9\n# Acceso al elemento de la segunda fila y tercera columna\nx[\"f2\", \"c3\"]\n#> [1] 8\n# Acceso a la submatriz de la primera y tercera filas, y tercera y segunda columnas\nx[c(\"f1\", \"f3\"), c(\"c3\", \"c2\")]\n#>    c3 c2\n#> f1  7  4\n#> f3  9  6"},{"path":"tipos-de-datos-estructurados.html","id":"modificación-de-los-elementos-de-un-vector","chapter":"Capítulo 3 Tipos de datos estructurados","heading":"3.1.6 Modificación de los elementos de un vector","text":"Para modificar uno o varios elementos de un vector basta con acceder esos elementos y usar el operador de asignación para asignar nuevos valores.Ejemplo 3.11  continuación se muestran varios ejemplos de modificación de los elementos de un vector.","code":"\nx <- c(1, 2, 3)\nx[2] <- 0\nx\n#> [1] 1 0 3\nx[c(1, 3)] <- 1\nx\n#> [1] 1 0 1"},{"path":"tipos-de-datos-estructurados.html","id":"añadir-elementos-a-un-vector","chapter":"Capítulo 3 Tipos de datos estructurados","heading":"3.1.7 Añadir elementos a un vector","text":"Para añadir nuevos elementos un vector pueden usarse las siguientes funciones:c(x, y): Devuelve el vector que resulta de añadir al vector x los elementos del vector y.append(x, y, pos): Devuelve el vector que resulta de añadir al vector x los elementos del vector y, continuación de la posición pos. El parámetro pos es opcional y si se indica, los elementos de y se añaden al final de los de x.Ejemplo 3.12  continuación se muestran varios ejemplos de añadir nuevos elementos un vector.","code":"\nx <- c(1, 2, 3)\ny <- c(x, c(4, 5))\ny\n#> [1] 1 2 3 4 5\ny <- append(x, c(4, 5), 2)\ny\n#> [1] 1 2 4 5 3"},{"path":"tipos-de-datos-estructurados.html","id":"eliminación-de-un-vector","chapter":"Capítulo 3 Tipos de datos estructurados","heading":"3.1.8 Eliminación de un vector","text":"Para eliminar los elementos de un vector basta con asignar NULL la variable que lo contiene, pero si se quiere liberar la memoria que ocupa la variable se utiliza la función rm().","code":""},{"path":"tipos-de-datos-estructurados.html","id":"listas","chapter":"Capítulo 3 Tipos de datos estructurados","heading":"3.2 Listas","text":"Las listas son colecciones ordenadas de elementos de que pueden ser de distintos tipos. Los elementos de una lista también pueden ser de tipos estructurados (vectores o listas), lo que las convierte en el tipo de dato más versátil de R. Como veremos más adelante, otras estructuras de datos como los data frames o los propios modelos estadísticos se construyen usando listas.","code":""},{"path":"tipos-de-datos-estructurados.html","id":"creación-de-listas","chapter":"Capítulo 3 Tipos de datos estructurados","heading":"3.2.1 Creación de listas","text":"Para construir una lista se utiliza la función list():list(x1, x2, ...): Devuelve la lista con los elementos x1, x2, etc.Ejemplo 3.13  continuación se muestran varios ejemplos de creación de listas.","code":"\nlist(1, \"dos\", TRUE)\n#> [[1]]\n#> [1] 1\n#> \n#> [[2]]\n#> [1] \"dos\"\n#> \n#> [[3]]\n#> [1] TRUE\n# Lista con vectores y listas\nx <- list(1, c(\"dos\", \"tres\"), list(4, \"cinco\"))\nx\n#> [[1]]\n#> [1] 1\n#> \n#> [[2]]\n#> [1] \"dos\"  \"tres\"\n#> \n#> [[3]]\n#> [[3]][[1]]\n#> [1] 4\n#> \n#> [[3]][[2]]\n#> [1] \"cinco\"\nstr(x)\n#> List of 3\n#>  $ : num 1\n#>  $ : chr [1:2] \"dos\" \"tres\"\n#>  $ :List of 2\n#>   ..$ : num 4\n#>   ..$ : chr \"cinco\"\n# Lista vacía\nlist()\n#> list()"},{"path":"tipos-de-datos-estructurados.html","id":"listas-con-nombres","chapter":"Capítulo 3 Tipos de datos estructurados","heading":"3.2.1.1 Listas con nombres","text":"Ejemplo 3.14  continuación se muestra un ejemplo de creación de una lista con nombres.Para obtener los nombres de una lista se utiliza la siguiente función:names(x): Devuelve un vector de cadenas de caracteres con los nombres de los elementos de la lista x.Ejemplo 3.15  continuación se muestra un ejemplo de acceso los nombres de una lista.","code":"\nlist(\"nombre\" = \"María\", \"edad\" = 21, \"dirección\" = list(\"calle\" = \"Delicias\", \"número\" = 24, \"municipio\" = \"Madrid\"))\n#> $nombre\n#> [1] \"María\"\n#> \n#> $edad\n#> [1] 21\n#> \n#> $dirección\n#> $dirección$calle\n#> [1] \"Delicias\"\n#> \n#> $dirección$número\n#> [1] 24\n#> \n#> $dirección$municipio\n#> [1] \"Madrid\"\npersona <- list(\"nombre\" = \"María\", \"edad\" = 21, \"dirección\" = list(\"calle\" = \"Delicias\", \"número\" = 24, \"municipio\" = \"Madrid\"))\nnames(persona)\n#> [1] \"nombre\"    \"edad\"      \"dirección\""},{"path":"tipos-de-datos-estructurados.html","id":"tamaño-de-una-lista","chapter":"Capítulo 3 Tipos de datos estructurados","heading":"3.2.2 Tamaño de una lista","text":"El número de elementos de una lista es su tamaño y puede averiguarse con la siguiente función:lenght(x): Devuelve el número de elementos de la lista x.Ejemplo 3.16  continuación se muestran varios ejemplos la obtención del tamaño de una lista.","code":"\nlength(list(1, \"dos\", TRUE))\n#> [1] 3\nlength(list(1, c(\"dos\", \"tres\"), list(4, \"cinco\")))\n#> [1] 3\nlength(list())\n#> [1] 0"},{"path":"tipos-de-datos-estructurados.html","id":"acceso-a-los-elementos-de-una-lista","chapter":"Capítulo 3 Tipos de datos estructurados","heading":"3.2.3 Acceso a los elementos de una lista","text":"Se accede los elementos de una lista de forma similar los vectores, mediante índices enteros, lógicos o de cadena, entre corchetes [ ].","code":""},{"path":"tipos-de-datos-estructurados.html","id":"acceso-mediante-un-índice-entero-1","chapter":"Capítulo 3 Tipos de datos estructurados","heading":"3.2.3.1 Acceso mediante un índice entero","text":"Al igual que los vectores, los elementos de una lista están ordenados y se puede utilizar un índice entero para acceder los elementos que ocupan una determinada posición.Ejemplo 3.17  continuación se muestran varios ejemplos de acceso los elementos de una lista mediante índices enteros.","code":"\nx <- list(1, \"dos\", TRUE, 4.5)\n# Acceso al elemento que está en la segunda posición\nx[2]\n#> [[1]]\n#> [1] \"dos\"\n# Acceso a los elementos de las posiciones 1 y 3\nx[c(1, 3)]\n#> [[1]]\n#> [1] 1\n#> \n#> [[2]]\n#> [1] TRUE\n# Acceso a todos los elementos excepto el primero y el cuarto\nx[c(-1, -4)]\n#> [[1]]\n#> [1] \"dos\"\n#> \n#> [[2]]\n#> [1] TRUE"},{"path":"tipos-de-datos-estructurados.html","id":"acceso-mediante-un-índice-lógico-1","chapter":"Capítulo 3 Tipos de datos estructurados","heading":"3.2.3.2 Acceso mediante un índice lógico","text":"Cuando se utiliza un índice lógico, se obtienen los elementos correspondientes las posiciones donde está el valor booleano TRUE.Ejemplo 3.18  continuación se muestran varios ejemplos de acceso los elementos de una lista mediante índices lógicos.Obsérvese que para los elementos que tiene sentido la comparación se obtiene NA, y que el acceso mediante este índice devuelve NULL.","code":"\nx <- list(1, \"dos\", TRUE, 4.5)\nx[c(T,F,F,T)]\n#> [[1]]\n#> [1] 1\n#> \n#> [[2]]\n#> [1] 4.5\nx < 2\n#> Warning: NAs introducidos por coerción\n#> [1]  TRUE    NA  TRUE FALSE\n# Filtrado de valores menores que 2\nx[x < 2]\n#> Warning: NAs introducidos por coerción\n#> [[1]]\n#> [1] 1\n#> \n#> [[2]]\n#> NULL\n#> \n#> [[3]]\n#> [1] TRUE"},{"path":"tipos-de-datos-estructurados.html","id":"acceso-mediante-un-índice-de-cadena-1","chapter":"Capítulo 3 Tipos de datos estructurados","heading":"3.2.3.3 Acceso mediante un índice de cadena","text":"Si los elementos de una lista tienen nombre, se puede acceder ellos utilizando sus nombres como índices. La única diferencia con el acceso mediante cadenas de vectores es que se obtiene siempre una lista, incluso cuando sólo se quiere acceder un elemento. Para obtener un elemento, y una lista con ese único elemento, se utilizan dobles corchetes [[ ]].Ejemplo 3.19  continuación se muestran varios ejemplos de acceso los elementos de una lista mediante índices de cadena.Una alternativa los dobles corchetes es el operador de acceso listas $. Este operador además permite utilizar coincidencias parciales en los nombres de los elementos para acceder ellos.Ejemplo 3.20  continuación se muestran varios ejemplos de acceso los elementos de una lista mediante el operador $.","code":"\npersona <- list(\"nombre\" = \"María\", \"edad\" = 21, \"dirección\" = list(\"calle\" = \"Delicias\", \"número\" = 24, \"municipio\" = \"Madrid\"))\npersona[c(\"edad\", \"nombre\")]\n#> $edad\n#> [1] 21\n#> \n#> $nombre\n#> [1] \"María\"\npersona[\"nombre\"]\n#> $nombre\n#> [1] \"María\"\ntypeof(persona[\"nombre\"])\n#> [1] \"list\"\n# Acceso a un único elemento\npersona[[\"nombre\"]]\n#> [1] \"María\"\n# Acceso a una lista anidada\npersona[[\"dirección\"]][[\"municipio\"]]\n#> [1] \"Madrid\"\npersona <- list(\"nombre\" = \"María\", \"edad\" = 21, \"dirección\" = list(\"calle\" = \"Delicias\", \"número\" = 24, \"municipio\" = \"Madrid\"))\n# Acceso a un único elemento\npersona$nombre\n#> [1] \"María\"\n# Acceso mediante coincidencia parcial\npersona$nom\n#> [1] \"María\"\n# Acceso a una lista anidada\npersona$dirección$municipio\n#> [1] \"Madrid\""},{"path":"tipos-de-datos-estructurados.html","id":"modificación-de-los-elementos-de-una-lista","chapter":"Capítulo 3 Tipos de datos estructurados","heading":"3.2.4 Modificación de los elementos de una lista","text":"Para modificar uno o varios elementos de una lista basta con acceder esos elementos y reasignarles valors con el operador de asignación.Ejemplo 3.21  continuación se muestran varios ejemplos de modificación de los elementos de una lista.","code":"\npersona <- list(\"nombre\" = \"María\", \"edad\" = 21)\npersona$edad <- 22\npersona\n#> $nombre\n#> [1] \"María\"\n#> \n#> $edad\n#> [1] 22"},{"path":"tipos-de-datos-estructurados.html","id":"añadir-elementos-a-una-lista","chapter":"Capítulo 3 Tipos de datos estructurados","heading":"3.2.5 Añadir elementos a una lista","text":"La forma más sencilla de añadir un elemento con nombre una lista es indicando el nombre con el operador $ y asignándole un valor con el operador de asignación <-:x$nombre <- y: Añade el elemento y la lista x con el nombre nombre.El nuevo elemento se añade siempre al final de la lista.Para añadir elementos sin nombre o en una posición determinada se puede utilizar la función append():append(x, y, pos): Devuelve la lista vector que resulta de añadir x los elementos de la lista y, continuación de la posición pos. El parámetro pos es opcional y si se indica, los elementos de y se añaden al final de los de x.Ejemplo 3.22  continuación se muestran varios ejemplos de añadir nuevos elementos una lista.","code":"\npersona <- list(\"nombre\" = \"María\", \"edad\" = 21)\npersona$email <- \"maria@ceu.es\"\npersona\n#> $nombre\n#> [1] \"María\"\n#> \n#> $edad\n#> [1] 21\n#> \n#> $email\n#> [1] \"maria@ceu.es\"\nappend(persona, list(\"sexo\" = \"Mujer\"), 2)\n#> $nombre\n#> [1] \"María\"\n#> \n#> $edad\n#> [1] 21\n#> \n#> $sexo\n#> [1] \"Mujer\"\n#> \n#> $email\n#> [1] \"maria@ceu.es\""},{"path":"tipos-de-datos-estructurados.html","id":"conversión-de-una-lista-en-un-vector","chapter":"Capítulo 3 Tipos de datos estructurados","heading":"3.2.6 Conversión de una lista en un vector","text":"Es posible convertir una lista en un vector con la siguiente función:unlist(x): Devuelve el vector que resulta de aplanar recursivamente la lista x y convertir todos los elementos al mismo tipo mediante coerción de tipos.Ejemplo 3.23  continuación se muestran varios ejemplos de conversión de una lista en un vector.","code":"\npersona <- list(\"nombre\" = \"María\", \"edad\" = 21, \"dirección\" = list(\"calle\" = \"Delicias\", \"número\" = 24, \"municipio\" = \"Madrid\"))\nunlist(persona)\n#>              nombre                edad     dirección.calle \n#>             \"María\"                \"21\"          \"Delicias\" \n#>    dirección.número dirección.municipio \n#>                \"24\"            \"Madrid\"\ntypeof(unlist(persona))\n#> [1] \"character\""},{"path":"tipos-de-datos-estructurados.html","id":"matrices","chapter":"Capítulo 3 Tipos de datos estructurados","heading":"3.3 Matrices","text":"Una matriz es una estructura de datos bidimensional de elementos del mismo tipo organizados en filas y columnas. Una matriz es similar un vector pero contiene una atributo adicional con sus dimensiones (número de filas y número de columnas).","code":""},{"path":"tipos-de-datos-estructurados.html","id":"creación-de-matrices","chapter":"Capítulo 3 Tipos de datos estructurados","heading":"3.3.1 Creación de matrices","text":"Para crear una matriz se utiliza la siguiente función:matrix(x, nrow = m, ncol = n): Devuelve la matriz con los elementos del vector x organizados en n filas y m columnas. Habitualmente basta con especificar el número de filas o el número de columnas.Ejemplo 3.24  continuación se muestran varios ejemplos de creación de matrices.Como se puede observar en el ejemplo anterior, los elementos se disponen por columnas, pero se pueden disponer los elementos por filas pasando el parámetro byrow = TRUE la función matrix.Ejemplo 3.25  continuación se muestran varios ejemplos de creación de matrices.","code":"\nmatrix(1:6, nrow = 2, ncol = 3)\n#>      [,1] [,2] [,3]\n#> [1,]    1    3    5\n#> [2,]    2    4    6\nmatrix(1:6, nrow = 2)\n#>      [,1] [,2] [,3]\n#> [1,]    1    3    5\n#> [2,]    2    4    6\nmatrix(1:6, ncol = 3)\n#>      [,1] [,2] [,3]\n#> [1,]    1    3    5\n#> [2,]    2    4    6\n# La matriz de 1 x 1 \nmatrix()\n#>      [,1]\n#> [1,]   NA\nmatrix(1:6, nrow = 2)\n#>      [,1] [,2] [,3]\n#> [1,]    1    3    5\n#> [2,]    2    4    6\nmatrix(1:6, nrow = 2, byrow = TRUE)\n#>      [,1] [,2] [,3]\n#> [1,]    1    2    3\n#> [2,]    4    5    6"},{"path":"tipos-de-datos-estructurados.html","id":"matrices-con-nombres-de-filas-y-columnas","chapter":"Capítulo 3 Tipos de datos estructurados","heading":"3.3.1.1 Matrices con nombres de filas y columnas","text":"Es posible poner nombres las filas y las columnas de una matriz añadiendo el parámetro dimnames y pasándole una lista de dos vectores de cadenas con los nombres de las filas y las columnas respectivamente.Ejemplo 3.26  continuación se muestran varios ejemplos de creación de matrices con nombres de filas y columnas.Para obtener los nombres de las filas y las columnas de una matriz se utilizan las siguientes funciones:rownames(x): Devuelve un vector de cadenas de caracteres con los nombres de las filas de la matriz x.colnames(x): Devuelve un vector de cadenas de caracteres con los nombres de las columnas de la matriz x.Ejemplo 3.27  continuación se muestran varios ejemplos de creación de matrices con nombres de filas y columnas.","code":"\nmatrix(1:6, nrow = 2, ncol = 3, dimnames = list(c(\"fila1\", \"fila2\"), c(\"columna1\", \"columna2\", \"columna3\")))\n#>       columna1 columna2 columna3\n#> fila1        1        3        5\n#> fila2        2        4        6\nx <- matrix(1:6, nrow = 2, ncol = 3, dimnames = list(c(\"fila1\", \"fila2\"), c(\"columna1\", \"columna2\", \"columna3\")))\nrownames(x)\n#> [1] \"fila1\" \"fila2\"\ncolnames(x)\n#> [1] \"columna1\" \"columna2\" \"columna3\""},{"path":"tipos-de-datos-estructurados.html","id":"tamaño-y-dimensiones-de-una-matriz","chapter":"Capítulo 3 Tipos de datos estructurados","heading":"3.3.2 Tamaño y dimensiones de una matriz","text":"Para obtener el número de elementos y las dimensiones de una matriz se pueden utilizar las siguientes funciones:length(x): Devuelve un entero con el número de elementos de la matriz x.nrow(x): Devuelve un entero con el número de filas de la matriz x.ncol(x): Devuelve un entero con el número de columnas de la matriz x.dim(x): Devuelve un vector de dos enteros con el número de filas y el número de columnas de la matriz x.Ejemplo 3.28  continuación se muestran varios ejemplos de acceso las dimensiones de una matriz.Usando esta última función se pueden modificar las dimensiones de una matriz asignando un vector de dos enteros con las nuevas dimensiones. Esto también permite crear una matriz partir de un vector.Ejemplo 3.29  continuación se muestran varios ejemplos de modificación de las dimensiones de una matriz.","code":"\nx <- matrix(1:6, nrow = 2)\nlength(x)\n#> [1] 6\nnrow(x)\n#> [1] 2\nncol(x)\n#> [1] 3\ndim(x)\n#> [1] 2 3\nx <- 1:6\ndim(x) <- c(2, 3)\nx\n#>      [,1] [,2] [,3]\n#> [1,]    1    3    5\n#> [2,]    2    4    6\ndim(x) <- c(3, 2)\nx\n#>      [,1] [,2]\n#> [1,]    1    4\n#> [2,]    2    5\n#> [3,]    3    6"},{"path":"tipos-de-datos-estructurados.html","id":"acceso-a-los-elementos-de-una-matriz","chapter":"Capítulo 3 Tipos de datos estructurados","heading":"3.3.3 Acceso a los elementos de una matriz","text":"Para acceder los elementos de una matriz se utilizan dos índices (uno para las filas y otro para las columnas), separados por comas y entre corchetes [] continuación de la matriz. Al igual que para los vectores, los índices pueden ser enteros, lógicos o de cadenas de caracteres.","code":""},{"path":"tipos-de-datos-estructurados.html","id":"acceso-mediante-índices-enteros","chapter":"Capítulo 3 Tipos de datos estructurados","heading":"3.3.3.1 Acceso mediante índices enteros","text":"Para acceder los elementos de una matriz mediante índices enteros se indica el número de fila y el número de columna del elemento entre corchetes:x[,j]: Devuelve el elemento de la matriz x que está en la fila y la columna j.Se puede acceder más de un elemento indicando un vector de enteros para las filas y otro para las columnas. De esta manera se obtiene una submatriz. Si se indica la fila o la columna se obtienen todos los elementos de todas las filas o columnas. Al igual que para vectores, se pueden utilizar enteros negativos para descartar filas o columnasEjemplo 3.30  continuación se muestran varios ejemplos de acceso los elementos de una matriz.","code":"\nx <- matrix(1:9, nrow = 3)\nx\n#>      [,1] [,2] [,3]\n#> [1,]    1    4    7\n#> [2,]    2    5    8\n#> [3,]    3    6    9\n# Acceso al elemento de la segunda fila y tercera columna\nx[2,3]\n#> [1] 8\n# Acceso a la submatriz de la primera y tercera filas, y tercera y segunda columnas\nx[c(1, 3), c(3, 2)]\n#>      [,1] [,2]\n#> [1,]    7    4\n#> [2,]    9    6\n# Acceso a la primera fila\nx[1, ]\n#> [1] 1 4 7\n# Acceso a la segunda columna\nx[, 2]\n#> [1] 4 5 6\n# Acceso a la submatriz con todos los elementos salvo la tercera fila y la segunda columna\nx[-3, -2]\n#>      [,1] [,2]\n#> [1,]    1    7\n#> [2,]    2    8"},{"path":"tipos-de-datos-estructurados.html","id":"acceso-mediante-índices-lógicos","chapter":"Capítulo 3 Tipos de datos estructurados","heading":"3.3.3.2 Acceso mediante índices lógicos","text":"Cuando se utilizan índices lógicos, se obtienen los elementos correspondientes las filas y columnas donde está el valor booleano TRUE.Ejemplo 3.31  continuación se muestran varios ejemplos de acceso los elementos de una matriz.","code":"\nx <- matrix(1:9, nrow = 3)\nx\n#>      [,1] [,2] [,3]\n#> [1,]    1    4    7\n#> [2,]    2    5    8\n#> [3,]    3    6    9\n# Acceso al elemento de la segunda fila y tercera columna\nx[c(F, T, F), c(F, F, T)]\n#> [1] 8\n# Acceso a la submatriz de la primera y tercera filas, y segunda y tercera columnas\nx[c(T, F, T), c(F, T, T)]\n#>      [,1] [,2]\n#> [1,]    4    7\n#> [2,]    6    9\n# Acceso a la primera fila\nx[c(T, F, F), ]\n#> [1] 1 4 7\n# Acceso a la segunda columna\nx[, c(F, T, F)]\n#> [1] 4 5 6"},{"path":"tipos-de-datos-estructurados.html","id":"acceso-mediante-índices-de-cadena","chapter":"Capítulo 3 Tipos de datos estructurados","heading":"3.3.3.3 Acceso mediante índices de cadena","text":"Si las filas y las columnas de una matriz tienen nombre, es posible acceder sus elementos usando los nombres de las filas y columnas como índices.","code":"\nx <- matrix(1:9, nrow = 3, dimnames = list(c(\"f1\", \"f2\", \"f3\"), c(\"c1\", \"c2\", \"c3\")))\nx\n#>    c1 c2 c3\n#> f1  1  4  7\n#> f2  2  5  8\n#> f3  3  6  9\n# Acceso al elemento de la segunda fila y tercera columna\nx[\"f2\", \"c3\"]\n#> [1] 8\n# Acceso a la submatriz de la primera y tercera filas, y tercera y segunda columnas\nx[c(\"f1\", \"f3\"), c(\"c3\", \"c2\")]\n#>    c3 c2\n#> f1  7  4\n#> f3  9  6"},{"path":"tipos-de-datos-estructurados.html","id":"data-frames","chapter":"Capítulo 3 Tipos de datos estructurados","heading":"3.4 Data frames","text":"","code":""},{"path":"estructuras-de-control.html","id":"estructuras-de-control","chapter":"Capítulo 4 Estructuras de control","heading":"Capítulo 4 Estructuras de control","text":"","code":""},{"path":"estructuras-de-control.html","id":"estructuras-condicionales","chapter":"Capítulo 4 Estructuras de control","heading":"4.1 Estructuras condicionales","text":"","code":""},{"path":"estructuras-de-control.html","id":"la-instrucción-if","chapter":"Capítulo 4 Estructuras de control","heading":"4.1.1 La instrucción if","text":"","code":""},{"path":"estructuras-de-control.html","id":"la-función-ifelse","chapter":"Capítulo 4 Estructuras de control","heading":"4.1.2 La función ifelse()","text":"","code":""},{"path":"estructuras-de-control.html","id":"la-función-switch","chapter":"Capítulo 4 Estructuras de control","heading":"4.1.3 La función switch()","text":"","code":""},{"path":"estructuras-de-control.html","id":"bucles","chapter":"Capítulo 4 Estructuras de control","heading":"4.2 Bucles","text":"","code":""},{"path":"estructuras-de-control.html","id":"bucles-iterativos-for","chapter":"Capítulo 4 Estructuras de control","heading":"4.2.1 Bucles iterativos (for)","text":"","code":""},{"path":"estructuras-de-control.html","id":"bucles-condicionales","chapter":"Capítulo 4 Estructuras de control","heading":"4.2.2 Bucles condicionales","text":"","code":""},{"path":"estructuras-de-control.html","id":"la-instrucción-while","chapter":"Capítulo 4 Estructuras de control","heading":"4.2.2.1 La instrucción while","text":"","code":""},{"path":"estructuras-de-control.html","id":"la-instrucción-repeat","chapter":"Capítulo 4 Estructuras de control","heading":"4.2.2.2 La instrucción repeat","text":"","code":""},{"path":"funciones.html","id":"funciones","chapter":"Capítulo 5 Funciones","heading":"Capítulo 5 Funciones","text":"","code":""},{"path":"funciones.html","id":"definición-y-llamada-a-funciones","chapter":"Capítulo 5 Funciones","heading":"5.1 Definición y llamada a funciones","text":"","code":""},{"path":"funciones.html","id":"parámetros-y-argumentos-de-una-función","chapter":"Capítulo 5 Funciones","heading":"5.2 Parámetros y argumentos de una función","text":"","code":""},{"path":"funciones.html","id":"retorno-de-una-fucinón","chapter":"Capítulo 5 Funciones","heading":"5.3 Retorno de una fucinón","text":"","code":""},{"path":"funciones.html","id":"entorno-y-ámbito-de-las-variables","chapter":"Capítulo 5 Funciones","heading":"5.4 Entorno y ámbito de las variables","text":"","code":""},{"path":"funciones.html","id":"funciones-recursivas","chapter":"Capítulo 5 Funciones","heading":"5.5 Funciones recursivas","text":"","code":""},{"path":"funciones.html","id":"paquetes","chapter":"Capítulo 5 Funciones","heading":"5.6 Paquetes","text":"","code":""},{"path":"preprocesamiento-de-datos.html","id":"preprocesamiento-de-datos","chapter":"Capítulo 6 Preprocesamiento de datos","heading":"Capítulo 6 Preprocesamiento de datos","text":"","code":""},{"path":"preprocesamiento-de-datos.html","id":"la-colección-de-paquetes-tiddyverse","chapter":"Capítulo 6 Preprocesamiento de datos","heading":"6.1 La colección de paquetes tiddyverse","text":"","code":""},{"path":"preprocesamiento-de-datos.html","id":"datos-ordenados-y-tibbles","chapter":"Capítulo 6 Preprocesamiento de datos","heading":"6.2 Datos ordenados y tibbles","text":"","code":""},{"path":"preprocesamiento-de-datos.html","id":"creación-de-nuevas-variables","chapter":"Capítulo 6 Preprocesamiento de datos","heading":"6.3 Creación de nuevas variables","text":"","code":""},{"path":"preprocesamiento-de-datos.html","id":"selección-de-variables","chapter":"Capítulo 6 Preprocesamiento de datos","heading":"6.4 Selección de variables","text":"","code":""},{"path":"preprocesamiento-de-datos.html","id":"filtrado-de-datos","chapter":"Capítulo 6 Preprocesamiento de datos","heading":"6.5 Filtrado de datos","text":"","code":""},{"path":"preprocesamiento-de-datos.html","id":"agrupación-de-datos","chapter":"Capítulo 6 Preprocesamiento de datos","heading":"6.6 Agrupación de datos","text":"","code":""},{"path":"preprocesamiento-de-datos.html","id":"resumen-de-datos","chapter":"Capítulo 6 Preprocesamiento de datos","heading":"6.7 Resumen de datos","text":"","code":""},{"path":"gráficos-y-visualización-de-datos.html","id":"gráficos-y-visualización-de-datos","chapter":"Capítulo 7 Gráficos y visualización de datos","heading":"Capítulo 7 Gráficos y visualización de datos","text":"","code":""},{"path":"gráficos-y-visualización-de-datos.html","id":"gramática-de-gráficos-y-el-paquete-ggplot2","chapter":"Capítulo 7 Gráficos y visualización de datos","heading":"7.1 Gramática de gráficos y el paquete ggplot2","text":"","code":""},{"path":"gráficos-y-visualización-de-datos.html","id":"diagramas-de-puntos","chapter":"Capítulo 7 Gráficos y visualización de datos","heading":"7.2 Diagramas de puntos","text":"","code":""},{"path":"gráficos-y-visualización-de-datos.html","id":"diagramas-de-barras","chapter":"Capítulo 7 Gráficos y visualización de datos","heading":"7.3 Diagramas de barras","text":"","code":""},{"path":"gráficos-y-visualización-de-datos.html","id":"diagramas-de-líneas","chapter":"Capítulo 7 Gráficos y visualización de datos","heading":"7.4 Diagramas de líneas","text":"","code":""},{"path":"gráficos-y-visualización-de-datos.html","id":"histogramas","chapter":"Capítulo 7 Gráficos y visualización de datos","heading":"7.5 Histogramas","text":"","code":""},{"path":"gráficos-y-visualización-de-datos.html","id":"diagramas-de-cajas","chapter":"Capítulo 7 Gráficos y visualización de datos","heading":"7.6 Diagramas de cajas","text":"","code":""},{"path":"gráficos-y-visualización-de-datos.html","id":"diagramas-de-dispersión","chapter":"Capítulo 7 Gráficos y visualización de datos","heading":"7.7 Diagramas de dispersión","text":"","code":""},{"path":"gráficos-y-visualización-de-datos.html","id":"personalización-de-gráficos","chapter":"Capítulo 7 Gráficos y visualización de datos","heading":"7.8 Personalización de gráficos","text":"","code":""},{"path":"gráficos-y-visualización-de-datos.html","id":"ejes","chapter":"Capítulo 7 Gráficos y visualización de datos","heading":"7.8.1 Ejes","text":"","code":""},{"path":"gráficos-y-visualización-de-datos.html","id":"leyendas","chapter":"Capítulo 7 Gráficos y visualización de datos","heading":"7.8.2 Leyendas","text":"","code":""},{"path":"gráficos-y-visualización-de-datos.html","id":"facetas","chapter":"Capítulo 7 Gráficos y visualización de datos","heading":"7.8.3 Facetas","text":"","code":""},{"path":"estadística-descriptiva.html","id":"estadística-descriptiva","chapter":"Capítulo 8 Estadística descriptiva","heading":"Capítulo 8 Estadística descriptiva","text":"","code":""},{"path":"estadística-descriptiva.html","id":"tablas-de-frecuencias","chapter":"Capítulo 8 Estadística descriptiva","heading":"8.1 Tablas de frecuencias","text":"","code":""},{"path":"estadística-descriptiva.html","id":"tablas-de-frecuencias-de-una-variable","chapter":"Capítulo 8 Estadística descriptiva","heading":"8.1.1 Tablas de frecuencias de una variable","text":"","code":""},{"path":"estadística-descriptiva.html","id":"tablas-de-frecuencias-de-dos-variables-tablas-de-contingencia","chapter":"Capítulo 8 Estadística descriptiva","heading":"8.1.2 Tablas de frecuencias de dos variables (tablas de contingencia)","text":"","code":""},{"path":"estadística-descriptiva.html","id":"estadísticos-de-tendencia-central","chapter":"Capítulo 8 Estadística descriptiva","heading":"8.2 Estadísticos de tendencia central","text":"","code":""},{"path":"estadística-descriptiva.html","id":"media","chapter":"Capítulo 8 Estadística descriptiva","heading":"8.2.1 Media","text":"","code":""},{"path":"estadística-descriptiva.html","id":"mediana","chapter":"Capítulo 8 Estadística descriptiva","heading":"8.2.2 Mediana","text":"","code":""},{"path":"estadística-descriptiva.html","id":"moda","chapter":"Capítulo 8 Estadística descriptiva","heading":"8.2.3 Moda","text":"","code":""},{"path":"estadística-descriptiva.html","id":"estadísticos-de-posición","chapter":"Capítulo 8 Estadística descriptiva","heading":"8.3 Estadísticos de posición","text":"","code":""},{"path":"estadística-descriptiva.html","id":"mínimo-y-máximo","chapter":"Capítulo 8 Estadística descriptiva","heading":"8.3.1 Mínimo y máximo","text":"","code":""},{"path":"estadística-descriptiva.html","id":"percentiles","chapter":"Capítulo 8 Estadística descriptiva","heading":"8.3.2 Percentiles","text":"","code":""},{"path":"estadística-descriptiva.html","id":"estadísticos-de-dispersión","chapter":"Capítulo 8 Estadística descriptiva","heading":"8.4 Estadísticos de dispersión","text":"","code":""},{"path":"estadística-descriptiva.html","id":"rango","chapter":"Capítulo 8 Estadística descriptiva","heading":"8.4.1 Rango","text":"","code":""},{"path":"estadística-descriptiva.html","id":"rango-intercuartílico","chapter":"Capítulo 8 Estadística descriptiva","heading":"8.4.2 Rango intercuartílico","text":"","code":""},{"path":"estadística-descriptiva.html","id":"varianza-y-cuasivarianza","chapter":"Capítulo 8 Estadística descriptiva","heading":"8.4.3 Varianza y cuasivarianza","text":"","code":""},{"path":"estadística-descriptiva.html","id":"desviación-típica-y-cuasidesviación-típica","chapter":"Capítulo 8 Estadística descriptiva","heading":"8.4.4 Desviación típica y cuasidesviación típica","text":"","code":""},{"path":"estadística-descriptiva.html","id":"coeficiente-de-variación","chapter":"Capítulo 8 Estadística descriptiva","heading":"8.4.5 Coeficiente de variación","text":"","code":""},{"path":"estadística-descriptiva.html","id":"estadísticos-de-forma","chapter":"Capítulo 8 Estadística descriptiva","heading":"8.5 Estadísticos de forma","text":"","code":""},{"path":"estadística-descriptiva.html","id":"coeficiente-de-asimetría","chapter":"Capítulo 8 Estadística descriptiva","heading":"8.5.1 Coeficiente de asimetría","text":"","code":""},{"path":"estadística-descriptiva.html","id":"coeficiente-de-apuntamiento","chapter":"Capítulo 8 Estadística descriptiva","heading":"8.5.2 Coeficiente de apuntamiento","text":"","code":""},{"path":"estadística-descriptiva.html","id":"resúmenes-descriptivos","chapter":"Capítulo 8 Estadística descriptiva","heading":"8.6 Resúmenes descriptivos","text":"","code":""},{"path":"estimación-de-parámetros-y-contrastes-de-hipótesis-de-variables-cuantitativas.html","id":"estimación-de-parámetros-y-contrastes-de-hipótesis-de-variables-cuantitativas","chapter":"Capítulo 9 Estimación de parámetros y contrastes de hipótesis de variables cuantitativas","heading":"Capítulo 9 Estimación de parámetros y contrastes de hipótesis de variables cuantitativas","text":"","code":""},{"path":"estimación-de-parámetros-y-contrastes-de-hipótesis-de-variables-cuantitativas.html","id":"contraste-para-la-media-de-una-población","chapter":"Capítulo 9 Estimación de parámetros y contrastes de hipótesis de variables cuantitativas","heading":"9.1 Contraste para la media de una población","text":"","code":""},{"path":"estimación-de-parámetros-y-contrastes-de-hipótesis-de-variables-cuantitativas.html","id":"contraste-para-la-comparación-de-medias-de-dos-poblaciones","chapter":"Capítulo 9 Estimación de parámetros y contrastes de hipótesis de variables cuantitativas","heading":"9.2 Contraste para la comparación de medias de dos poblaciones","text":"","code":""},{"path":"estimación-de-parámetros-y-contrastes-de-hipótesis-de-variables-cuantitativas.html","id":"poblaciones-pareadas","chapter":"Capítulo 9 Estimación de parámetros y contrastes de hipótesis de variables cuantitativas","heading":"9.2.1 Poblaciones pareadas","text":"","code":""},{"path":"estimación-de-parámetros-y-contrastes-de-hipótesis-de-variables-cuantitativas.html","id":"poblaciones-independientes","chapter":"Capítulo 9 Estimación de parámetros y contrastes de hipótesis de variables cuantitativas","heading":"9.2.2 Poblaciones independientes","text":"","code":""},{"path":"estimación-de-parámetros-y-contrastes-de-hipótesis-de-variables-cuantitativas.html","id":"contraste-para-la-comparación-de-medias-de-más-de-dos-poblaciones-anova","chapter":"Capítulo 9 Estimación de parámetros y contrastes de hipótesis de variables cuantitativas","heading":"9.3 Contraste para la comparación de medias de más de dos poblaciones (ANOVA)","text":"","code":""},{"path":"estimación-de-parámetros-y-contrastes-de-hipótesis-de-variables-cuantitativas.html","id":"contrastes-de-comparación-por-pares-post-hoc.","chapter":"Capítulo 9 Estimación de parámetros y contrastes de hipótesis de variables cuantitativas","heading":"9.3.1 Contrastes de comparación por pares post-hoc.","text":"","code":""},{"path":"estimación-de-parámetros-y-contrastes-de-hipótesis-de-variables-cualitativas.html","id":"estimación-de-parámetros-y-contrastes-de-hipótesis-de-variables-cualitativas","chapter":"Capítulo 10 Estimación de parámetros y contrastes de hipótesis de variables cualitativas","heading":"Capítulo 10 Estimación de parámetros y contrastes de hipótesis de variables cualitativas","text":"","code":""},{"path":"estimación-de-parámetros-y-contrastes-de-hipótesis-de-variables-cualitativas.html","id":"contraste-para-la-proporción-de-una-población","chapter":"Capítulo 10 Estimación de parámetros y contrastes de hipótesis de variables cualitativas","heading":"10.1 Contraste para la proporción de una población","text":"","code":""},{"path":"estimación-de-parámetros-y-contrastes-de-hipótesis-de-variables-cualitativas.html","id":"contraste-para-la-comparación-de-proporciones-de-dos-poblaciones","chapter":"Capítulo 10 Estimación de parámetros y contrastes de hipótesis de variables cualitativas","heading":"10.2 Contraste para la comparación de proporciones de dos poblaciones","text":"","code":""},{"path":"estimación-de-parámetros-y-contrastes-de-hipótesis-de-variables-cualitativas.html","id":"poblaciones-pareadas-1","chapter":"Capítulo 10 Estimación de parámetros y contrastes de hipótesis de variables cualitativas","heading":"10.2.1 Poblaciones pareadas","text":"","code":""},{"path":"estimación-de-parámetros-y-contrastes-de-hipótesis-de-variables-cualitativas.html","id":"poblaciones-independientes-1","chapter":"Capítulo 10 Estimación de parámetros y contrastes de hipótesis de variables cualitativas","heading":"10.2.2 Poblaciones independientes","text":"","code":""},{"path":"estimación-de-parámetros-y-contrastes-de-hipótesis-de-variables-cualitativas.html","id":"contraste-para-la-comparación-de-proporciones-de-más-de-dos-poblaciones","chapter":"Capítulo 10 Estimación de parámetros y contrastes de hipótesis de variables cualitativas","heading":"10.3 Contraste para la comparación de proporciones de más de dos poblaciones","text":"","code":""},{"path":"análisis-de-regresión-simple.html","id":"análisis-de-regresión-simple","chapter":"Capítulo 11 Análisis de regresión simple","heading":"Capítulo 11 Análisis de regresión simple","text":"","code":""},{"path":"análisis-de-regresión-simple.html","id":"regresión-lineal","chapter":"Capítulo 11 Análisis de regresión simple","heading":"11.1 Regresión lineal","text":"","code":""},{"path":"análisis-de-regresión-simple.html","id":"correlación","chapter":"Capítulo 11 Análisis de regresión simple","heading":"11.2 Correlación","text":"","code":""},{"path":"análisis-de-regresión-simple.html","id":"regresión-no-lineal","chapter":"Capítulo 11 Análisis de regresión simple","heading":"11.3 Regresión no lineal","text":"","code":""},{"path":"análisis-de-regresión-simple.html","id":"regresión-múltiple","chapter":"Capítulo 11 Análisis de regresión simple","heading":"11.4 Regresión múltiple","text":"","code":""}]
